/* automatically generated by rust-bindgen 0.69.5 */
#![allow(warnings)]
#![allow(clippy::all)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const FUSE_USE_VERSION: u32 = 27;
pub const FUSE_OPT_KEY_OPT: i32 = -1;
pub const FUSE_OPT_KEY_NONOPT: i32 = -2;
pub const FUSE_OPT_KEY_KEEP: i32 = -3;
pub const FUSE_OPT_KEY_DISCARD: i32 = -4;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_FILE_OFFSET64: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const FUSE_MAJOR_VERSION: u32 = 2;
pub const FUSE_MINOR_VERSION: u32 = 7;
pub const _FCNTL_H: u32 = 1;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __time_t_defined: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _BITS_STRUCT_STAT_H: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _SYS_STAT_H: u32 = 1;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const AFC_SERVICE_NAME: &[u8; 14] = b"com.apple.afc\0";
pub const _SYS_STATVFS_H: u32 = 1;
#[doc = " Option description\n\n This structure describes a single option, and and action associated\n with it, in case it matches.\n\n More than one such match may occur, in which case the action for\n each match is executed.\n\n There are three possible actions in case of a match:\n\n i) An integer (int or unsigned) variable determined by 'offset' is\n    set to 'value'\n\n ii) The processing function is called, with 'value' as the key\n\n iii) An integer (any) or string (char *) variable determined by\n    'offset' is set to the value of an option parameter\n\n 'offset' should normally be either set to\n\n  - 'offsetof(struct foo, member)'  actions i) and iii)\n\n  - -1\t\t\t      action ii)\n\n The 'offsetof()' macro is defined in the <stddef.h> header.\n\n The template determines which options match, and also have an\n effect on the action.  Normally the action is either i) or ii), but\n if a format is present in the template, then action iii) is\n performed.\n\n The types of templates are:\n\n 1) \"-x\", \"-foo\", \"--foo\", \"--foo-bar\", etc.\tThese match only\n   themselves.  Invalid values are \"--\" and anything beginning\n   with \"-o\"\n\n 2) \"foo\", \"foo-bar\", etc.  These match \"-ofoo\", \"-ofoo-bar\" or\n    the relevant option in a comma separated option list\n\n 3) \"bar=\", \"--foo=\", etc.  These are variations of 1) and 2)\n    which have a parameter\n\n 4) \"bar=%s\", \"--foo=%lu\", etc.  Same matching as above but perform\n    action iii).\n\n 5) \"-x \", etc.  Matches either \"-xparam\" or \"-x param\" as\n    two separate arguments\n\n 6) \"-x %s\", etc.  Combination of 4) and 5)\n\n If the format is \"%s\", memory is allocated for the string unlike\n with scanf()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fuse_opt {
    #[doc = " Matching template and optional parameter formatting"]
    pub templ: *const ::std::os::raw::c_char,
    #[doc = " Offset of variable within 'data' parameter of fuse_opt_parse()\n or -1"]
    pub offset: ::std::os::raw::c_ulong,
    #[doc = " Value to set the variable to, or to be passed as 'key' to the\n processing function.\t Ignored if template has a format"]
    pub value: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fuse_opt() {
    const UNINIT: ::std::mem::MaybeUninit<fuse_opt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fuse_opt>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_opt>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_opt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).templ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_opt),
            "::",
            stringify!(templ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_opt),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_opt),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Argument list"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fuse_args {
    #[doc = " Argument count"]
    pub argc: ::std::os::raw::c_int,
    #[doc = " Argument vector.  NULL terminated"]
    pub argv: *mut *mut ::std::os::raw::c_char,
    #[doc = " Is 'argv' allocated?"]
    pub allocated: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fuse_args() {
    const UNINIT: ::std::mem::MaybeUninit<fuse_args> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fuse_args>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_args))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_args>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_args))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_args),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_args),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocated) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_args),
            "::",
            stringify!(allocated)
        )
    );
}
#[doc = " Processing function\n\n This function is called if\n    - option did not match any 'struct fuse_opt'\n    - argument is a non-option\n    - option did match and offset was set to -1\n\n The 'arg' parameter will always contain the whole argument or\n option including the parameter if exists.  A two-argument option\n (\"-x foo\") is always converted to single arguemnt option of the\n form \"-xfoo\" before this function is called.\n\n Options of the form '-ofoo' are passed to this function without the\n '-o' prefix.\n\n The return value of this function determines whether this argument\n is to be inserted into the output argument vector, or discarded.\n\n @param data is the user data passed to the fuse_opt_parse() function\n @param arg is the whole argument or option\n @param key determines why the processing function was called\n @param outargs the current output argument list\n @return -1 on error, 0 if arg is to be discarded, 1 if arg should be kept"]
pub type fuse_opt_proc_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        arg: *const ::std::os::raw::c_char,
        key: ::std::os::raw::c_int,
        outargs: *mut fuse_args,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Option parsing function\n\n If 'args' was returned from a previous call to fuse_opt_parse() or\n it was constructed from\n\n A NULL 'args' is equivalent to an empty argument vector\n\n A NULL 'opts' is equivalent to an 'opts' array containing a single\n end marker\n\n A NULL 'proc' is equivalent to a processing function always\n returning '1'\n\n @param args is the input and output argument list\n @param data is the user data\n @param opts is the option description array\n @param proc is the processing function\n @return -1 on error, 0 on success"]
    pub fn fuse_opt_parse(
        args: *mut fuse_args,
        data: *mut ::std::os::raw::c_void,
        opts: *const fuse_opt,
        proc_: fuse_opt_proc_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an option to a comma separated option list\n\n @param opts is a pointer to an option list, may point to a NULL value\n @param opt is the option to add\n @return -1 on allocation error, 0 on success"]
    pub fn fuse_opt_add_opt(
        opts: *mut *mut ::std::os::raw::c_char,
        opt: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an argument to a NULL terminated argument vector\n\n @param args is the structure containing the current argument list\n @param arg is the new argument to add\n @return -1 on allocation error, 0 on success"]
    pub fn fuse_opt_add_arg(
        args: *mut fuse_args,
        arg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an argument at the specified position in a NULL terminated\n argument vector\n\n Adds the argument to the N-th position.  This is useful for adding\n options at the beginning of the array which must not come after the\n special '--' option.\n\n @param args is the structure containing the current argument list\n @param pos is the position at which to add the argument\n @param arg is the new argument to add\n @return -1 on allocation error, 0 on success"]
    pub fn fuse_opt_insert_arg(
        args: *mut fuse_args,
        pos: ::std::os::raw::c_int,
        arg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the contents of argument list\n\n The structure itself is not freed\n\n @param args is the structure containing the argument list"]
    pub fn fuse_opt_free_args(args: *mut fuse_args);
}
extern "C" {
    #[doc = " Check if an option matches\n\n @param opts is the option description array\n @param opt is the option to match\n @return 1 if a match is found, 0 if not"]
    pub fn fuse_opt_match(
        opts: *const fuse_opt,
        opt: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = u64;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = u64;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = u64;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = u64; //::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = i64;
pub type __off64_t = u64;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = u64;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = u64;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = u64;
pub type __suseconds64_t = u64;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = u64;
pub type __blkcnt_t = u64;
pub type __blkcnt64_t = u64;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = u64;
pub type __ssize_t = u64;
pub type __syscall_slong_t = u64;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = u64;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = u64;
pub type int_fast32_t = u64;
pub type int_fast64_t = u64;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Information about open files\n\n Changed in version 2.5"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fuse_file_info {
    #[doc = " Open flags.\t Available in open() and release()"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " Old file handle, don't use"]
    pub fh_old: ::std::os::raw::c_ulong,
    #[doc = " In case of a write operation indicates if this was caused by a\nwritepage"]
    pub writepage: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " File handle.  May be filled in by filesystem in open().\nAvailable in all other file operations"]
    pub fh: u64,
    #[doc = " Lock owner id.  Available in locking operations and flush"]
    pub lock_owner: u64,
}
#[test]
fn bindgen_test_layout_fuse_file_info() {
    const UNINIT: ::std::mem::MaybeUninit<fuse_file_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fuse_file_info>(),
        40usize,
        concat!("Size of: ", stringify!(fuse_file_info))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_file_info>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_file_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_file_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fh_old) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_file_info),
            "::",
            stringify!(fh_old)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writepage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_file_info),
            "::",
            stringify!(writepage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_file_info),
            "::",
            stringify!(fh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock_owner) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_file_info),
            "::",
            stringify!(lock_owner)
        )
    );
}
impl fuse_file_info {
    #[inline]
    pub fn direct_io(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_direct_io(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_cache(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_cache(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn padding(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_padding(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        direct_io: ::std::os::raw::c_uint,
        keep_cache: ::std::os::raw::c_uint,
        flush: ::std::os::raw::c_uint,
        padding: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let direct_io: u32 = unsafe { ::std::mem::transmute(direct_io) };
            direct_io as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let keep_cache: u32 = unsafe { ::std::mem::transmute(keep_cache) };
            keep_cache as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let flush: u32 = unsafe { ::std::mem::transmute(flush) };
            flush as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let padding: u32 = unsafe { ::std::mem::transmute(padding) };
            padding as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Connection information, passed to the ->init() method\n\n Some of the elements are read-write, these can be changed to\n indicate the value requested by the filesystem.  The requested\n value must usually be smaller than the indicated value."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fuse_conn_info {
    #[doc = " Major version of the protocol (read-only)"]
    pub proto_major: ::std::os::raw::c_uint,
    #[doc = " Minor version of the protocol (read-only)"]
    pub proto_minor: ::std::os::raw::c_uint,
    #[doc = " Is asynchronous read supported (read-write)"]
    pub async_read: ::std::os::raw::c_uint,
    #[doc = " Maximum size of the write buffer"]
    pub max_write: ::std::os::raw::c_uint,
    #[doc = " Maximum readahead"]
    pub max_readahead: ::std::os::raw::c_uint,
    #[doc = " For future use."]
    pub reserved: [::std::os::raw::c_uint; 27usize],
}
#[test]
fn bindgen_test_layout_fuse_conn_info() {
    const UNINIT: ::std::mem::MaybeUninit<fuse_conn_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fuse_conn_info>(),
        128usize,
        concat!("Size of: ", stringify!(fuse_conn_info))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_conn_info>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_conn_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_conn_info),
            "::",
            stringify!(proto_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_conn_info),
            "::",
            stringify!(proto_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).async_read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_conn_info),
            "::",
            stringify!(async_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_write) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_conn_info),
            "::",
            stringify!(max_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_readahead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_conn_info),
            "::",
            stringify!(max_readahead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_conn_info),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_chan {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a FUSE mountpoint\n\n Returns a control file descriptor suitable for passing to\n fuse_new()\n\n @param mountpoint the mount point path\n @param args argument vector\n @return the communication channel on success, NULL on failure"]
    pub fn fuse_mount(
        mountpoint: *const ::std::os::raw::c_char,
        args: *mut fuse_args,
    ) -> *mut fuse_chan;
}
extern "C" {
    #[doc = " Umount a FUSE mountpoint\n\n @param mountpoint the mount point path\n @param ch the communication channel"]
    pub fn fuse_unmount(mountpoint: *const ::std::os::raw::c_char, ch: *mut fuse_chan);
}
extern "C" {
    #[doc = " Parse common options\n\n The following options are parsed:\n\n   '-f'\t     foreground\n   '-d' '-odebug'  foreground, but keep the debug option\n   '-s'\t     single threaded\n   '-h' '--help'   help\n   '-ho'\t     help without header\n   '-ofsname=..'   file system name, if not present, then set to the program\n\t\t     name\n\n All parameters may be NULL\n\n @param args argument vector\n @param mountpoint the returned mountpoint, should be freed after use\n @param multithreaded set to 1 unless the '-s' option is present\n @param foreground set to 1 if one of the relevant options is present\n @return 0 on success, -1 on failure"]
    pub fn fuse_parse_cmdline(
        args: *mut fuse_args,
        mountpoint: *mut *mut ::std::os::raw::c_char,
        multithreaded: *mut ::std::os::raw::c_int,
        foreground: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Go into the background\n\n @param foreground if true, stay in the foreground\n @return 0 on success, -1 on failure"]
    pub fn fuse_daemonize(foreground: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the version of the library\n\n @return the version"]
    pub fn fuse_version() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Exit session on HUP, TERM and INT signals and ignore PIPE signal\n\n Stores session in a global variable.\t May only be called once per\n process until fuse_remove_signal_handlers() is called.\n\n @param se the session to exit\n @return 0 on success, -1 on failure"]
    pub fn fuse_set_signal_handlers(se: *mut fuse_session) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Restore default signal handlers\n\n Resets global session.  After this fuse_set_signal_handlers() may\n be called again.\n\n @param se the same session as given in fuse_set_signal_handlers()"]
    pub fn fuse_remove_signal_handlers(se: *mut fuse_session);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off64_t,
    pub l_len: __off64_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    const UNINIT: ::std::mem::MaybeUninit<flock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
}
pub type mode_t = __mode_t;
pub type off_t = __off64_t;
pub type pid_t = __pid_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
/*
   dev_t st_dev;
   ino_t st_ino;
   unsigned short st_mode;
   short st_nlink;
   short st_uid;
   short st_gid;
   dev_t st_rdev;
   FUSE_OFF_T st_size;
   time_t st_atime;
   time_t st_mtime;
   time_t st_ctime;
*/
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    // pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    // pub st_blksize: __blksize_t,
    // pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    // pub __glibc_reserved: [__syscall_slong_t; 3usize],
}

#[test]
fn bindgen_test_layout_stat() {
    const UNINIT: ::std::mem::MaybeUninit<stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atim) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtim) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctim) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}fcntl64"]
    pub fn fcntl(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}open64"]
    pub fn open(
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}openat64"]
    pub fn openat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}creat64"]
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}lockf64"]
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}posix_fadvise64"]
    pub fn posix_fadvise(
        __fd: ::std::os::raw::c_int,
        __offset: __off64_t,
        __len: __off64_t,
        __advise: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}posix_fallocate64"]
    pub fn posix_fallocate(
        __fd: ::std::os::raw::c_int,
        __offset: __off64_t,
        __len: __off64_t,
    ) -> ::std::os::raw::c_int;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: u64,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: u64;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: u64;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt64_t;
pub type fsblkcnt_t = __fsblkcnt64_t;
pub type fsfilcnt_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl ::std::fmt::Debug for __atomic_wide_counter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__atomic_wide_counter {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl ::std::fmt::Debug for __pthread_cond_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "__pthread_cond_s {{ __wseq: {:?}, __g1_start: {:?}, __g_refs: {:?}, __g_size: {:?}, __g1_orig_size: {:?}, __wrefs: {:?}, __g_signals: {:?} }}" , self . __wseq , self . __g1_start , self . __g_refs , self . __g_size , self . __g1_orig_size , self . __wrefs , self . __g_signals)
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_mutexattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_mutexattr_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_condattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_condattr_t {{ union }}")
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: u64,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_attr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_attr_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: u64,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_mutex_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_mutex_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: u64,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_cond_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_cond_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_rwlock_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_rwlock_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_rwlockattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_rwlockattr_t {{ union }}")
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: u64,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_barrier_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_barrier_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_barrierattr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_barrierattr_t {{ union }}")
    }
}
extern "C" {
    #[link_name = "\u{1}stat64"]
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}fstat64"]
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}fstatat64"]
    pub fn fstatat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}lstat64"]
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
#[doc = " Handle for a FUSE filesystem"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse {
    _unused: [u8; 0],
}
#[doc = " Structure containing a raw command"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_cmd {
    _unused: [u8; 0],
}
#[doc = " Function to add an entry in a readdir() operation\n\n @param buf the buffer passed to the readdir() operation\n @param name the file name of the directory entry\n @param stbuf file attributes, can be NULL\n @param off offset of the next entry or zero\n @return 1 if buffer is full, zero otherwise"]
pub type fuse_fill_dir_t = ::std::option::Option<
    unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        stbuf: *const stat,
        off: off_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_dirhandle {
    _unused: [u8; 0],
}
pub type fuse_dirh_t = *mut fuse_dirhandle;
pub type fuse_dirfil_t = ::std::option::Option<
    unsafe extern "C" fn(
        h: fuse_dirh_t,
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        ino: ino_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " The file system operations:\n\n Most of these should work very similarly to the well known UNIX\n file system operations.\n\n All methods are optional, but some are essential for a useful\n filesystem (e.g. getattr).  Open, flush, release, fsync, opendir,\n releasedir, fsyncdir, access, create, ftruncate, fgetattr, lock,\n init and destroy are special purpose methods, without which a full\n featured filesystem can still be implemented."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fuse_operations {
    #[doc = " Get file attributes.\n\n Similar to stat().  The 'st_dev' and 'st_blksize' fields are\n ignored.\t The 'st_ino' field is ignored except if the 'use_ino'\n mount option is given."]
    pub getattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut stat,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read the target of a symbolic link\n\n The buffer should be filled with a null terminated string.  The\n buffer size argument includes the space for the terminating\n null character.\tIf the linkname is too long to fit in the\n buffer, it should be truncated.\tThe return value should be 0\n for success."]
    pub readlink: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut ::std::os::raw::c_char,
            arg3: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub getdir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: fuse_dirh_t,
            arg3: fuse_dirfil_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Create a file node\n\n This is called for creation of all non-directory, non-symlink\n nodes.  If the filesystem defines a create() method, then for\n regular files that will be called instead."]
    pub mknod: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: mode_t,
            arg3: dev_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Create a directory"]
    pub mkdir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: mode_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove a file"]
    pub unlink: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove a directory"]
    pub rmdir: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
    #[doc = " Create a symbolic link"]
    pub symlink: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Rename a file"]
    pub rename: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Create a hard link to a file"]
    pub link: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Change the permission bits of a file"]
    pub chmod: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: mode_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Change the owner and group of a file"]
    pub chown: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: uid_t,
            arg3: gid_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Change the size of a file"]
    pub truncate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: off_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Change the access and/or modification times of a file\n\n Deprecated, use utimens() instead."]
    pub utime: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut utimbuf,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " File open operation\n\n No creation, or truncation flags (O_CREAT, O_EXCL, O_TRUNC)\n will be passed to open().  Open should check if the operation\n is permitted for the given flags.  Optionally open may also\n return an arbitrary filehandle in the fuse_file_info structure,\n which will be passed to all file operations.\n\n Changed in version 2.2"]
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read data from an open file\n\n Read should return exactly the number of bytes requested except\n on EOF or error, otherwise the rest of the data will be\n substituted with zeroes.\t An exception to this is when the\n 'direct_io' mount option is specified, in which case the return\n value of the read system call will reflect the return value of\n this operation.\n\n Changed in version 2.2"]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut ::std::os::raw::c_char,
            arg3: size_t,
            arg4: off_t,
            arg5: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Write data to an open file\n\n Write should return exactly the number of bytes requested\n except on error.\t An exception to this is when the 'direct_io'\n mount option is specified (see read operation).\n\n Changed in version 2.2"]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: size_t,
            arg4: off_t,
            arg5: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get file system statistics\n\n The 'f_frsize', 'f_favail', 'f_fsid' and 'f_flag' fields are ignored\n\n Replaced 'struct statfs' parameter with 'struct statvfs' in\n version 2.5"]
    pub statfs: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut statvfs,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Possibly flush cached data\n\n BIG NOTE: This is not equivalent to fsync().  It's not a\n request to sync dirty data.\n\n Flush is called on each close() of a file descriptor.  So if a\n filesystem wants to return write errors in close() and the file\n has cached dirty data, this is a good place to write back data\n and return any errors.  Since many applications ignore close()\n errors this is not always useful.\n\n NOTE: The flush() method may be called more than once for each\n open().\tThis happens if more than one file descriptor refers\n to an opened file due to dup(), dup2() or fork() calls.\tIt is\n not possible to determine if a flush is final, so each flush\n should be treated equally.  Multiple write-flush sequences are\n relatively rare, so this shouldn't be a problem.\n\n Filesystems shouldn't assume that flush will always be called\n after some writes, or that if will be called at all.\n\n Changed in version 2.2"]
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Release an open file\n\n Release is called when there are no more references to an open\n file: all file descriptors are closed and all memory mappings\n are unmapped.\n\n For every open() call there will be exactly one release() call\n with the same flags and file descriptor.\t It is possible to\n have a file opened more than once, in which case only the last\n release will mean, that no more reads/writes will happen on the\n file.  The return value of release is ignored.\n\n Changed in version 2.2"]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Synchronize file contents\n\n If the datasync parameter is non-zero, then only the user data\n should be flushed, not the meta data.\n\n Changed in version 2.2"]
    pub fsync: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
            arg3: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set extended attributes"]
    pub setxattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: size_t,
            arg5: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get extended attributes"]
    pub getxattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " List extended attributes"]
    pub listxattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut ::std::os::raw::c_char,
            arg3: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove extended attributes"]
    pub removexattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Open directory\n\n This method should check if the open operation is permitted for\n this  directory\n\n Introduced in version 2.3"]
    pub opendir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read directory\n\n This supersedes the old getdir() interface.  New applications\n should use this.\n\n The filesystem may choose between two modes of operation:\n\n 1) The readdir implementation ignores the offset parameter, and\n passes zero to the filler function's offset.  The filler\n function will not return '1' (unless an error happens), so the\n whole directory is read in a single readdir operation.  This\n works just like the old getdir() method.\n\n 2) The readdir implementation keeps track of the offsets of the\n directory entries.  It uses the offset parameter and always\n passes non-zero offset to the filler function.  When the buffer\n is full (or an error happens) the filler function will return\n '1'.\n\n Introduced in version 2.3"]
    pub readdir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut ::std::os::raw::c_void,
            arg3: fuse_fill_dir_t,
            arg4: off_t,
            arg5: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Release directory\n\n Introduced in version 2.3"]
    pub releasedir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Synchronize directory contents\n\n If the datasync parameter is non-zero, then only the user data\n should be flushed, not the meta data\n\n Introduced in version 2.3"]
    pub fsyncdir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
            arg3: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Initialize filesystem\n\n The return value will passed in the private_data field of\n fuse_context to all file operations and as a parameter to the\n destroy() method.\n\n Introduced in version 2.3\n Changed in version 2.6"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut fuse_conn_info) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Clean up filesystem\n\n Called on filesystem exit.\n\n Introduced in version 2.3"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = " Check file access permissions\n\n This will be called for the access() system call.  If the\n 'default_permissions' mount option is given, this method is not\n called.\n\n This method is not called under Linux kernel versions 2.4.x\n\n Introduced in version 2.5"]
    pub access: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Create and open a file\n\n If the file does not exist, first create it with the specified\n mode, and then open it.\n\n If this method is not implemented or under Linux kernel\n versions earlier than 2.6.15, the mknod() and open() methods\n will be called instead.\n\n Introduced in version 2.5"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: mode_t,
            arg3: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Change the size of an open file\n\n This method is called instead of the truncate() method if the\n truncation was invoked from an ftruncate() system call.\n\n If this method is not implemented or under Linux kernel\n versions earlier than 2.6.15, the truncate() method will be\n called instead.\n\n Introduced in version 2.5"]
    pub ftruncate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: off_t,
            arg3: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get attributes from an open file\n\n This method is called instead of the getattr() method if the\n file information is available.\n\n Currently this is only called after the create() method if that\n is implemented (see above).  Later it may be called for\n invocations of fstat() too.\n\n Introduced in version 2.5"]
    pub fgetattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut stat,
            arg3: *mut fuse_file_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Perform POSIX file locking operation\n\n The cmd argument will be either F_GETLK, F_SETLK or F_SETLKW.\n\n For the meaning of fields in 'struct flock' see the man page\n for fcntl(2).  The l_whence field will always be set to\n SEEK_SET.\n\n For checking lock ownership, the 'fuse_file_info->owner'\n argument must be used.\n\n For F_GETLK operation, the library will first check currently\n held locks, and if a conflicting lock is found it will return\n information without calling this method.\t This ensures, that\n for local locks the l_pid field is correctly filled in.\tThe\n results may not be accurate in case of race conditions and in\n the presence of hard links, but it's unlikly that an\n application would rely on accurate GETLK results in these\n cases.  If a conflicting lock is not found, this method will be\n called, and the filesystem may fill out l_pid by a meaningful\n value, or it may leave this field zero.\n\n For F_SETLK and F_SETLKW the l_pid field will be set to the pid\n of the process performing the locking operation.\n\n Note: if this method is not implemented, the kernel will still\n allow file locking to work locally.  Hence it is only\n interesting for network filesystems and similar.\n\n Introduced in version 2.6"]
    pub lock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut fuse_file_info,
            cmd: ::std::os::raw::c_int,
            arg3: *mut flock,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Change the access and modification times of a file with\n nanosecond resolution\n\n Introduced in version 2.6"]
    pub utimens: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            tv: *const timespec,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Map block index within file to block index within device\n\n Note: This makes sense only for block device backed filesystems\n mounted with the 'blkdev' option\n\n Introduced in version 2.6"]
    pub bmap: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            blocksize: size_t,
            idx: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_fuse_operations() {
    const UNINIT: ::std::mem::MaybeUninit<fuse_operations> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fuse_operations>(),
        304usize,
        concat!("Size of: ", stringify!(fuse_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_operations))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getattr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(getattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readlink) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(readlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getdir) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(getdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mknod) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(mknod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mkdir) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unlink) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(unlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rmdir) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symlink) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(symlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rename) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chmod) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(chmod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chown) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(chown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utime) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statfs) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(statfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsync) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(fsync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setxattr) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(setxattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getxattr) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(getxattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listxattr) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(listxattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removexattr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(removexattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opendir) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(opendir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readdir) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(readdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).releasedir) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(releasedir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsyncdir) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(fsyncdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftruncate) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(ftruncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fgetattr) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(fgetattr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utimens) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(utimens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bmap) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_operations),
            "::",
            stringify!(bmap)
        )
    );
}
#[doc = " Extra context that may be needed by some filesystems\n\n The uid, gid and pid fields are not filled in case of a writepage\n operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fuse_context {
    #[doc = " Pointer to the fuse object"]
    pub fuse: *mut fuse,
    #[doc = " User ID of the calling process"]
    pub uid: uid_t,
    #[doc = " Group ID of the calling process"]
    pub gid: gid_t,
    #[doc = " Thread ID of the calling process"]
    pub pid: pid_t,
    #[doc = " Private filesystem data"]
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_fuse_context() {
    const UNINIT: ::std::mem::MaybeUninit<fuse_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fuse_context>(),
        32usize,
        concat!("Size of: ", stringify!(fuse_context))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_context>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fuse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_context),
            "::",
            stringify!(fuse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_context),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_context),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_context),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_context),
            "::",
            stringify!(private_data)
        )
    );
}
extern "C" {
    #[doc = " Create a new FUSE filesystem.\n\n @param ch the communication channel\n @param args argument vector\n @param op the filesystem operations\n @param op_size the size of the fuse_operations structure\n @param user_data user data supplied in the context during the init() method\n @return the created FUSE handle"]
    pub fn fuse_new(
        ch: *mut fuse_chan,
        args: *mut fuse_args,
        op: *const fuse_operations,
        op_size: size_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut fuse;
}
extern "C" {
    #[doc = " Destroy the FUSE handle.\n\n The communication channel attached to the handle is also destroyed.\n\n NOTE: This function does not unmount the filesystem.\t If this is\n needed, call fuse_unmount() before calling this function.\n\n @param f the FUSE handle"]
    pub fn fuse_destroy(f: *mut fuse);
}
extern "C" {
    #[doc = " FUSE event loop.\n\n Requests from the kernel are processed, and the appropriate\n operations are called.\n\n @param f the FUSE handle\n @return 0 if no error occurred, -1 otherwise"]
    pub fn fuse_loop(f: *mut fuse) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Exit from event loop\n\n @param f the FUSE handle"]
    pub fn fuse_exit(f: *mut fuse);
}
extern "C" {
    #[doc = " FUSE event loop with multiple threads\n\n Requests from the kernel are processed, and the appropriate\n operations are called.  Request are processed in parallel by\n distributing them between multiple threads.\n\n Calling this function requires the pthreads library to be linked to\n the application.\n\n @param f the FUSE handle\n @return 0 if no error occurred, -1 otherwise"]
    pub fn fuse_loop_mt(f: *mut fuse) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current context\n\n The context is only valid for the duration of a filesystem\n operation, and thus must not be stored and used later.\n\n @return the context"]
    pub fn fuse_get_context() -> *mut fuse_context;
}
extern "C" {
    #[doc = " Check if a request has already been interrupted\n\n @return 1 if the request has been interrupted, 0 otherwise"]
    pub fn fuse_interrupted() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obsolete, doesn't do anything\n\n @return -EINVAL"]
    pub fn fuse_invalidate(
        f: *mut fuse,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_is_lib_option(opt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The real main function\n\n Do not call this directly, use fuse_main()"]
    pub fn fuse_main_real(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        op: *const fuse_operations,
        op_size: size_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Fuse filesystem object\n\n This is opaque object represents a filesystem layer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_fs {
    _unused: [u8; 0],
}
extern "C" {
    pub fn fuse_fs_getattr(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_fgetattr(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        buf: *mut stat,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_rename(
        fs: *mut fuse_fs,
        oldpath: *const ::std::os::raw::c_char,
        newpath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_unlink(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_rmdir(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_symlink(
        fs: *mut fuse_fs,
        linkname: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_link(
        fs: *mut fuse_fs,
        oldpath: *const ::std::os::raw::c_char,
        newpath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_release(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_open(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_read(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
        off: off_t,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_write(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_char,
        size: size_t,
        off: off_t,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_fsync(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        datasync: ::std::os::raw::c_int,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_flush(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_statfs(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        buf: *mut [u8; 0usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_opendir(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_readdir(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_void,
        filler: fuse_fill_dir_t,
        off: off_t,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_fsyncdir(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        datasync: ::std::os::raw::c_int,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_releasedir(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_create(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        mode: mode_t,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_lock(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        fi: *mut fuse_file_info,
        cmd: ::std::os::raw::c_int,
        lock: *mut flock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_chmod(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        mode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_chown(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        uid: uid_t,
        gid: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_truncate(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        size: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_ftruncate(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        size: off_t,
        fi: *mut fuse_file_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_utimens(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        tv: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_access(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_readlink(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_mknod(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        mode: mode_t,
        rdev: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_mkdir(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        mode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_setxattr(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        size: size_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_getxattr(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_listxattr(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        list: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_removexattr(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_bmap(
        fs: *mut fuse_fs,
        path: *const ::std::os::raw::c_char,
        blocksize: size_t,
        idx: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuse_fs_init(fs: *mut fuse_fs, conn: *mut fuse_conn_info);
}
extern "C" {
    pub fn fuse_fs_destroy(fs: *mut fuse_fs);
}
extern "C" {
    #[doc = " Create a new fuse filesystem object\n\n This is usually called from the factory of a fuse module to create\n a new instance of a filesystem.\n\n @param op the filesystem operations\n @param op_size the size of the fuse_operations structure\n @param user_data user data supplied in the context during the init() method\n @return a new filesystem object"]
    pub fn fuse_fs_new(
        op: *const fuse_operations,
        op_size: size_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut fuse_fs;
}
#[doc = " Filesystem module\n\n Filesystem modules are registered with the FUSE_REGISTER_MODULE()\n macro.\n\n If the \"-omodules=modname:...\" option is present, filesystem\n objects are created and pushed onto the stack with the 'factory'\n function."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fuse_module {
    #[doc = " Name of filesystem"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Factory for creating filesystem objects\n\n The function may use and remove options from 'args' that belong\n to this module.\n\n For now the 'fs' vector always contains exactly one filesystem.\n This is the filesystem which will be below the newly created\n filesystem in the stack.\n\n @param args the command line arguments\n @param fs NULL terminated filesystem object vector\n @return the new filesystem object"]
    pub factory: ::std::option::Option<
        unsafe extern "C" fn(args: *mut fuse_args, fs: *mut *mut fuse_fs) -> *mut fuse_fs,
    >,
    pub next: *mut fuse_module,
    pub so: *mut fusemod_so,
    pub ctr: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fuse_module() {
    const UNINIT: ::std::mem::MaybeUninit<fuse_module> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fuse_module>(),
        40usize,
        concat!("Size of: ", stringify!(fuse_module))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_module>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_module))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_module),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).factory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_module),
            "::",
            stringify!(factory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_module),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).so) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_module),
            "::",
            stringify!(so)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fuse_module),
            "::",
            stringify!(ctr)
        )
    );
}
extern "C" {
    #[doc = " Register a filesystem module\n\n This function is used by FUSE_REGISTER_MODULE and there's usually\n no need to call it directly"]
    pub fn fuse_register_module(mod_: *mut fuse_module);
}
#[doc = " Function type used to process commands"]
pub type fuse_processor_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut fuse, arg2: *mut fuse_cmd, arg3: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " This is the part of fuse_main() before the event loop"]
    pub fn fuse_setup(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        op: *const fuse_operations,
        op_size: size_t,
        mountpoint: *mut *mut ::std::os::raw::c_char,
        multithreaded: *mut ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut fuse;
}
extern "C" {
    #[doc = " This is the part of fuse_main() after the event loop"]
    pub fn fuse_teardown(fuse: *mut fuse, mountpoint: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Read a single command.  If none are read, return NULL"]
    pub fn fuse_read_cmd(f: *mut fuse) -> *mut fuse_cmd;
}
extern "C" {
    #[doc = " Process a single command"]
    pub fn fuse_process_cmd(f: *mut fuse, cmd: *mut fuse_cmd);
}
extern "C" {
    #[doc = " Multi threaded event loop, which calls the custom command\nprocessor function"]
    pub fn fuse_loop_mt_proc(
        f: *mut fuse,
        proc_: fuse_processor_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the exited flag, which indicates if fuse_exit() has been\ncalled"]
    pub fn fuse_exited(f: *mut fuse) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function is obsolete and implemented as a no-op"]
    pub fn fuse_set_getcontext_func(
        func: ::std::option::Option<unsafe extern "C" fn() -> *mut fuse_context>,
    );
}
extern "C" {
    #[doc = " Get session from fuse object"]
    pub fn fuse_get_session(f: *mut fuse) -> *mut fuse_session;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl ::std::fmt::Debug for __mbstate_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__mbstate_t__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "__mbstate_t {{ __count: {:?}, __value: {:?} }}",
            self.__count, self.__value
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl ::std::fmt::Debug for _G_fpos_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_G_fpos_t {{ __pos: {:?}, __state: {:?} }}",
            self.__pos, self.__state
        )
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl ::std::fmt::Debug for _G_fpos64_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_G_fpos64_t {{ __pos: {:?}, __state: {:?} }}",
            self.__pos, self.__state
        )
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: size_t,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: size_t,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type fpos_t = __fpos64_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}tmpfile64"]
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}fopen64"]
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}freopen64"]
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: u64,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> u64;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}fseeko64"]
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}ftello64"]
    pub fn ftello(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    #[link_name = "\u{1}fgetpos64"]
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}fsetpos64"]
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " The basic plist abstract data type."]
pub type plist_t = *mut ::std::os::raw::c_void;
#[doc = " The plist dictionary iterator."]
pub type plist_dict_iter = *mut ::std::os::raw::c_void;
#[doc = " The plist array iterator."]
pub type plist_array_iter = *mut ::std::os::raw::c_void;
#[doc = "< No type"]
pub const plist_type_PLIST_NONE: plist_type = -1;
#[doc = "< Boolean, scalar type"]
pub const plist_type_PLIST_BOOLEAN: plist_type = 0;
#[doc = "< Integer, scalar type"]
pub const plist_type_PLIST_INT: plist_type = 1;
#[doc = "< Real, scalar type"]
pub const plist_type_PLIST_REAL: plist_type = 2;
#[doc = "< ASCII string, scalar type"]
pub const plist_type_PLIST_STRING: plist_type = 3;
#[doc = "< Ordered array, structured type"]
pub const plist_type_PLIST_ARRAY: plist_type = 4;
#[doc = "< Unordered dictionary (key/value pair), structured type"]
pub const plist_type_PLIST_DICT: plist_type = 5;
#[doc = "< Date, scalar type"]
pub const plist_type_PLIST_DATE: plist_type = 6;
#[doc = "< Binary data, scalar type"]
pub const plist_type_PLIST_DATA: plist_type = 7;
#[doc = "< Key in dictionaries (ASCII String), scalar type"]
pub const plist_type_PLIST_KEY: plist_type = 8;
#[doc = "< Special type used for 'keyed encoding'"]
pub const plist_type_PLIST_UID: plist_type = 9;
#[doc = "< NULL type"]
pub const plist_type_PLIST_NULL: plist_type = 10;
#[doc = " The enumeration of plist node types."]
pub type plist_type = ::std::os::raw::c_int;
#[doc = "< operation successful"]
pub const plist_err_t_PLIST_ERR_SUCCESS: plist_err_t = 0;
#[doc = "< one or more of the parameters are invalid"]
pub const plist_err_t_PLIST_ERR_INVALID_ARG: plist_err_t = -1;
#[doc = "< the plist contains nodes not compatible with the output format"]
pub const plist_err_t_PLIST_ERR_FORMAT: plist_err_t = -2;
#[doc = "< parsing of the input format failed"]
pub const plist_err_t_PLIST_ERR_PARSE: plist_err_t = -3;
#[doc = "< not enough memory to handle the operation"]
pub const plist_err_t_PLIST_ERR_NO_MEM: plist_err_t = -4;
#[doc = "< I/O error"]
pub const plist_err_t_PLIST_ERR_IO: plist_err_t = -5;
#[doc = "< an unspecified error occurred"]
pub const plist_err_t_PLIST_ERR_UNKNOWN: plist_err_t = -255;
#[doc = " libplist error values"]
pub type plist_err_t = ::std::os::raw::c_int;
#[doc = "< No format"]
pub const plist_format_t_PLIST_FORMAT_NONE: plist_format_t = 0;
#[doc = "< XML format"]
pub const plist_format_t_PLIST_FORMAT_XML: plist_format_t = 1;
#[doc = "< bplist00 format"]
pub const plist_format_t_PLIST_FORMAT_BINARY: plist_format_t = 2;
#[doc = "< JSON format"]
pub const plist_format_t_PLIST_FORMAT_JSON: plist_format_t = 3;
#[doc = "< OpenStep \"old-style\" plist format"]
pub const plist_format_t_PLIST_FORMAT_OSTEP: plist_format_t = 4;
#[doc = "< human-readable output-only format"]
pub const plist_format_t_PLIST_FORMAT_PRINT: plist_format_t = 10;
#[doc = "< \"libimobiledevice\" output-only format (ideviceinfo)"]
pub const plist_format_t_PLIST_FORMAT_LIMD: plist_format_t = 11;
#[doc = "< plutil-style output-only format"]
pub const plist_format_t_PLIST_FORMAT_PLUTIL: plist_format_t = 12;
#[doc = " libplist format types"]
pub type plist_format_t = ::std::os::raw::c_uint;
#[doc = "< Default value to use when none of the options is needed."]
pub const plist_write_options_t_PLIST_OPT_NONE: plist_write_options_t = 0;
#[doc = "< Use a compact representation (non-prettified). Only valid for #PLIST_FORMAT_JSON and #PLIST_FORMAT_OSTEP."]
pub const plist_write_options_t_PLIST_OPT_COMPACT: plist_write_options_t = 1;
#[doc = "< Print 24 bytes maximum of #PLIST_DATA values. If the data is longer than 24 bytes,  the first 16 and last 8 bytes will be written. Only valid for #PLIST_FORMAT_PRINT."]
pub const plist_write_options_t_PLIST_OPT_PARTIAL_DATA: plist_write_options_t = 2;
#[doc = "< Do not print a final newline character. Only valid for #PLIST_FORMAT_PRINT, #PLIST_FORMAT_LIMD, and #PLIST_FORMAT_PLUTIL."]
pub const plist_write_options_t_PLIST_OPT_NO_NEWLINE: plist_write_options_t = 4;
#[doc = "< Indent each line of output. Currently only #PLIST_FORMAT_PRINT and #PLIST_FORMAT_LIMD are supported. Use #PLIST_OPT_INDENT_BY() macro to specify the level of indentation."]
pub const plist_write_options_t_PLIST_OPT_INDENT: plist_write_options_t = 8;
#[doc = " libplist write options"]
pub type plist_write_options_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a new root plist_t type #PLIST_DICT\n\n @return the created plist\n @sa #plist_type"]
    pub fn plist_new_dict() -> plist_t;
}
extern "C" {
    #[doc = " Create a new root plist_t type #PLIST_ARRAY\n\n @return the created plist\n @sa #plist_type"]
    pub fn plist_new_array() -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_STRING\n\n @param val the sting value, encoded in UTF8.\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_string(val: *const ::std::os::raw::c_char) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_BOOLEAN\n\n @param val the boolean value, 0 is false, other values are true.\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_bool(val: u8) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_INT with an unsigned integer value\n\n @param val the unsigned integer value\n @return the created item\n @sa #plist_type\n @note The value is always stored as uint64_t internally.\n    Use #plist_get_uint_val or #plist_get_int_val to get the unsigned or signed value."]
    pub fn plist_new_uint(val: u64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_INT with a signed integer value\n\n @param val the signed integer value\n @return the created item\n @sa #plist_type\n @note The value is always stored as uint64_t internally.\n    Use #plist_get_uint_val or #plist_get_int_val to get the unsigned or signed value."]
    pub fn plist_new_int(val: i64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_REAL\n\n @param val the real value\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_real(val: f64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_DATA\n\n @param val the binary buffer\n @param length the length of the buffer\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_data(val: *const ::std::os::raw::c_char, length: u64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_DATE\n\n @param sec The number of seconds since 01/01/1970 (UNIX timestamp)\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_unix_date(sec: i64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_UID\n\n @param val the unsigned integer value\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_uid(val: u64) -> plist_t;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_NULL\n @return the created item\n @sa #plist_type\n @note This type is not valid for all formats, e.g. the XML format\n     does not support it."]
    pub fn plist_new_null() -> plist_t;
}
extern "C" {
    #[doc = " Destruct a plist_t node and all its children recursively\n\n @param plist the plist to free"]
    pub fn plist_free(plist: plist_t);
}
extern "C" {
    #[doc = " Return a copy of passed node and it's children\n\n @param node the plist to copy\n @return copied plist"]
    pub fn plist_copy(node: plist_t) -> plist_t;
}
extern "C" {
    #[doc = " Get size of a #PLIST_ARRAY node.\n\n @param node the node of type #PLIST_ARRAY\n @return size of the #PLIST_ARRAY node"]
    pub fn plist_array_get_size(node: plist_t) -> u32;
}
extern "C" {
    #[doc = " Get the nth item in a #PLIST_ARRAY node.\n\n @param node the node of type #PLIST_ARRAY\n @param n the index of the item to get. Range is [0, array_size[\n @return the nth item or NULL if node is not of type #PLIST_ARRAY"]
    pub fn plist_array_get_item(node: plist_t, n: u32) -> plist_t;
}
extern "C" {
    #[doc = " Get the index of an item. item must be a member of a #PLIST_ARRAY node.\n\n @param node the node\n @return the node index or UINT_MAX if node index can't be determined"]
    pub fn plist_array_get_item_index(node: plist_t) -> u32;
}
extern "C" {
    #[doc = " Set the nth item in a #PLIST_ARRAY node.\n The previous item at index n will be freed using #plist_free\n\n @param node the node of type #PLIST_ARRAY\n @param item the new item at index n. The array is responsible for freeing item when it is no longer needed.\n @param n the index of the item to get. Range is [0, array_size[. Assert if n is not in range."]
    pub fn plist_array_set_item(node: plist_t, item: plist_t, n: u32);
}
extern "C" {
    #[doc = " Append a new item at the end of a #PLIST_ARRAY node.\n\n @param node the node of type #PLIST_ARRAY\n @param item the new item. The array is responsible for freeing item when it is no longer needed."]
    pub fn plist_array_append_item(node: plist_t, item: plist_t);
}
extern "C" {
    #[doc = " Insert a new item at position n in a #PLIST_ARRAY node.\n\n @param node the node of type #PLIST_ARRAY\n @param item the new item to insert. The array is responsible for freeing item when it is no longer needed.\n @param n The position at which the node will be stored. Range is [0, array_size[. Assert if n is not in range."]
    pub fn plist_array_insert_item(node: plist_t, item: plist_t, n: u32);
}
extern "C" {
    #[doc = " Remove an existing position in a #PLIST_ARRAY node.\n Removed position will be freed using #plist_free.\n\n @param node the node of type #PLIST_ARRAY\n @param n The position to remove. Range is [0, array_size[. Assert if n is not in range."]
    pub fn plist_array_remove_item(node: plist_t, n: u32);
}
extern "C" {
    #[doc = " Remove a node that is a child node of a #PLIST_ARRAY node.\n node will be freed using #plist_free.\n\n @param node The node to be removed from its #PLIST_ARRAY parent."]
    pub fn plist_array_item_remove(node: plist_t);
}
extern "C" {
    #[doc = " Create an iterator of a #PLIST_ARRAY node.\n The allocated iterator should be freed with the standard free function.\n\n @param node The node of type #PLIST_ARRAY\n @param iter Location to store the iterator for the array."]
    pub fn plist_array_new_iter(node: plist_t, iter: *mut plist_array_iter);
}
extern "C" {
    #[doc = " Increment iterator of a #PLIST_ARRAY node.\n\n @param node The node of type #PLIST_ARRAY.\n @param iter Iterator of the array\n @param item Location to store the item. The caller must *not* free the\n          returned item. Will be set to NULL when no more items are left\n          to iterate."]
    pub fn plist_array_next_item(node: plist_t, iter: plist_array_iter, item: *mut plist_t);
}
extern "C" {
    #[doc = " Get size of a #PLIST_DICT node.\n\n @param node the node of type #PLIST_DICT\n @return size of the #PLIST_DICT node"]
    pub fn plist_dict_get_size(node: plist_t) -> u32;
}
extern "C" {
    #[doc = " Create an iterator of a #PLIST_DICT node.\n The allocated iterator should be freed with the standard free function.\n\n @param node The node of type #PLIST_DICT.\n @param iter Location to store the iterator for the dictionary."]
    pub fn plist_dict_new_iter(node: plist_t, iter: *mut plist_dict_iter);
}
extern "C" {
    #[doc = " Increment iterator of a #PLIST_DICT node.\n\n @param node The node of type #PLIST_DICT\n @param iter Iterator of the dictionary\n @param key Location to store the key, or NULL. The caller is responsible\n\t\tfor freeing the the returned string.\n @param val Location to store the value, or NULL. The caller must *not*\n\t\tfree the returned value. Will be set to NULL when no more\n\t\tkey/value pairs are left to iterate."]
    pub fn plist_dict_next_item(
        node: plist_t,
        iter: plist_dict_iter,
        key: *mut *mut ::std::os::raw::c_char,
        val: *mut plist_t,
    );
}
extern "C" {
    #[doc = " Get key associated key to an item. Item must be member of a dictionary.\n\n @param node the item\n @param key a location to store the key. The caller is responsible for freeing the returned string."]
    pub fn plist_dict_get_item_key(node: plist_t, key: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get the nth item in a #PLIST_DICT node.\n\n @param node the node of type #PLIST_DICT\n @param key the identifier of the item to get.\n @return the item or NULL if node is not of type #PLIST_DICT. The caller should not free\n\t\tthe returned node."]
    pub fn plist_dict_get_item(node: plist_t, key: *const ::std::os::raw::c_char) -> plist_t;
}
extern "C" {
    #[doc = " Get key node associated to an item. Item must be member of a dictionary.\n\n @param node the item\n @return the key node of the given item, or NULL."]
    pub fn plist_dict_item_get_key(node: plist_t) -> plist_t;
}
extern "C" {
    #[doc = " Set item identified by key in a #PLIST_DICT node.\n The previous item identified by key will be freed using #plist_free.\n If there is no item for the given key a new item will be inserted.\n\n @param node the node of type #PLIST_DICT\n @param item the new item associated to key\n @param key the identifier of the item to set."]
    pub fn plist_dict_set_item(node: plist_t, key: *const ::std::os::raw::c_char, item: plist_t);
}
extern "C" {
    #[doc = " Remove an existing position in a #PLIST_DICT node.\n Removed position will be freed using #plist_free\n\n @param node the node of type #PLIST_DICT\n @param key The identifier of the item to remove. Assert if identifier is not present."]
    pub fn plist_dict_remove_item(node: plist_t, key: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Merge a dictionary into another. This will add all key/value pairs\n from the source dictionary to the target dictionary, overwriting\n any existing key/value pairs that are already present in target.\n\n @param target pointer to an existing node of type #PLIST_DICT\n @param source node of type #PLIST_DICT that should be merged into target"]
    pub fn plist_dict_merge(target: *mut plist_t, source: plist_t);
}
extern "C" {
    #[doc = " Get a boolean value from a given #PLIST_DICT entry.\n\n The value node can be of type #PLIST_BOOLEAN, but also\n #PLIST_STRING (either 'true' or 'false'),\n #PLIST_INT with a numerical value of 0 or >= 1,\n or #PLIST_DATA with a single byte with a value of 0 or >= 1.\n\n @note This function returns 0 if the dictionary does not contain an\n entry for the given key, if the value node is of any other than\n the above mentioned type, or has any mismatching value.\n\n @param dict A node of type #PLIST_DICT\n @param key The key to look for in dict\n @return 0 or 1 depending on the value of the node."]
    pub fn plist_dict_get_bool(dict: plist_t, key: *const ::std::os::raw::c_char) -> u8;
}
extern "C" {
    #[doc = " Get a signed integer value from a given #PLIST_DICT entry.\n The value node can be of type #PLIST_INT, but also\n #PLIST_STRING with a numerical value as string (decimal or hexadecimal),\n or #PLIST_DATA with a size of 1, 2, 4, or 8 bytes in little endian byte order.\n\n @note This function returns 0 if the dictionary does not contain an\n entry for the given key, if the value node is of any other than\n the above mentioned type, or has any mismatching value.\n\n @param dict A node of type #PLIST_DICT\n @param key The key to look for in dict\n @return Signed integer value depending on the value of the node."]
    pub fn plist_dict_get_int(dict: plist_t, key: *const ::std::os::raw::c_char) -> i64;
}
extern "C" {
    #[doc = " Get an unsigned integer value from a given #PLIST_DICT entry.\n The value node can be of type #PLIST_INT, but also\n #PLIST_STRING with a numerical value as string (decimal or hexadecimal),\n or #PLIST_DATA with a size of 1, 2, 4, or 8 bytes in little endian byte order.\n\n @note This function returns 0 if the dictionary does not contain an\n entry for the given key, if the value node is of any other than\n the above mentioned type, or has any mismatching value.\n\n @param dict A node of type #PLIST_DICT\n @param key The key to look for in dict\n @return Signed integer value depending on the value of the node."]
    pub fn plist_dict_get_uint(dict: plist_t, key: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    #[doc = " Copy a node from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key."]
    pub fn plist_dict_copy_item(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Copy a boolean value from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @note The boolean value from *source_dict* is retrieved with #plist_dict_get_bool,\n     but is **always** created as #PLIST_BOOLEAN in *target_dict*.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key."]
    pub fn plist_dict_copy_bool(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Copy a signed integer value from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @note The signed integer value from *source_dict* is retrieved with #plist_dict_get_int,\n     but is **always** created as #PLIST_INT.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node value to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key."]
    pub fn plist_dict_copy_int(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Copy an unsigned integer value from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @note The unsigned integer value from *source_dict* is retrieved with #plist_dict_get_uint,\n     but is **always** created as #PLIST_INT.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node value to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key."]
    pub fn plist_dict_copy_uint(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Copy a #PLIST_DATA node from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @note This function is like #plist_dict_copy_item, except that it fails\n     if the source node is not of type #PLIST_DATA.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node value to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key, or if it is not of type #PLIST_DATA."]
    pub fn plist_dict_copy_data(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Copy a #PLIST_STRING node from *source_dict* to *target_dict*.\n The node is looked up in *source_dict* with given *key*, unless *alt_source_key*\n is non-NULL, in which case it is looked up with *alt_source_key*.\n The entry in *target_dict* is **always** created with *key*.\n\n @note This function is like #plist_dict_copy_item, except that it fails\n     if the source node is not of type #PLIST_STRING.\n\n @param target_dict The target dictionary to copy to.\n @param source_dict The source dictionary to copy from.\n @param key The key for the node value to copy.\n @param alt_source_key The alternative source key for lookup in *source_dict* or NULL.\n\n @result PLIST_ERR_SUCCESS on success or PLIST_ERR_INVALID_ARG if the source dictionary does not contain\n     any entry with given key or alt_source_key, or if it is not of type #PLIST_STRING."]
    pub fn plist_dict_copy_string(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Get the parent of a node\n\n @param node the parent (NULL if node is root)"]
    pub fn plist_get_parent(node: plist_t) -> plist_t;
}
extern "C" {
    #[doc = " Get the #plist_type of a node.\n\n @param node the node\n @return the type of the node"]
    pub fn plist_get_node_type(node: plist_t) -> plist_type;
}
extern "C" {
    #[doc = " Get the value of a #PLIST_KEY node.\n This function does nothing if node is not of type #PLIST_KEY\n\n @param node the node\n @param val a pointer to a C-string. This function allocates the memory,\n            caller is responsible for freeing it.\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_get_key_val(node: plist_t, val: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_STRING node.\n This function does nothing if node is not of type #PLIST_STRING\n\n @param node the node\n @param val a pointer to a C-string. This function allocates the memory,\n            caller is responsible for freeing it. Data is UTF-8 encoded.\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_get_string_val(node: plist_t, val: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get a pointer to the buffer of a #PLIST_STRING node.\n\n @note DO NOT MODIFY the buffer. Mind that the buffer is only available\n   until the plist node gets freed. Make a copy if needed.\n\n @param node The node\n @param length If non-NULL, will be set to the length of the string\n\n @return Pointer to the NULL-terminated buffer."]
    pub fn plist_get_string_ptr(node: plist_t, length: *mut u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the value of a #PLIST_BOOLEAN node.\n This function does nothing if node is not of type #PLIST_BOOLEAN\n\n @param node the node\n @param val a pointer to a uint8_t variable."]
    pub fn plist_get_bool_val(node: plist_t, val: *mut u8);
}
extern "C" {
    #[doc = " Get the unsigned integer value of a #PLIST_INT node.\n This function does nothing if node is not of type #PLIST_INT\n\n @param node the node\n @param val a pointer to a uint64_t variable."]
    pub fn plist_get_uint_val(node: plist_t, val: *mut u64);
}
extern "C" {
    #[doc = " Get the signed integer value of a #PLIST_INT node.\n This function does nothing if node is not of type #PLIST_INT\n\n @param node the node\n @param val a pointer to a int64_t variable."]
    pub fn plist_get_int_val(node: plist_t, val: *mut i64);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_REAL node.\n This function does nothing if node is not of type #PLIST_REAL\n\n @param node the node\n @param val a pointer to a double variable."]
    pub fn plist_get_real_val(node: plist_t, val: *mut f64);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_DATA node.\n This function does nothing if node is not of type #PLIST_DATA\n\n @param node the node\n @param val a pointer to an unallocated char buffer. This function allocates the memory,\n            caller is responsible for freeing it.\n @param length the length of the buffer\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_get_data_val(
        node: plist_t,
        val: *mut *mut ::std::os::raw::c_char,
        length: *mut u64,
    );
}
extern "C" {
    #[doc = " Get a pointer to the data buffer of a #PLIST_DATA node.\n\n @note DO NOT MODIFY the buffer. Mind that the buffer is only available\n   until the plist node gets freed. Make a copy if needed.\n\n @param node The node\n @param length Pointer to a uint64_t that will be set to the length of the buffer\n\n @return Pointer to the buffer"]
    pub fn plist_get_data_ptr(node: plist_t, length: *mut u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the value of a #PLIST_DATE node.\n This function does nothing if node is not of type #PLIST_DATE\n\n @param node the node\n @param sec a pointer to an int64_t variable. Represents the number of seconds since 01/01/1970 (UNIX timestamp)."]
    pub fn plist_get_unix_date_val(node: plist_t, sec: *mut i64);
}
extern "C" {
    #[doc = " Get the value of a #PLIST_UID node.\n This function does nothing if node is not of type #PLIST_UID\n\n @param node the node\n @param val a pointer to a uint64_t variable."]
    pub fn plist_get_uid_val(node: plist_t, val: *mut u64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_KEY\n\n @param node the node\n @param val the key value"]
    pub fn plist_set_key_val(node: plist_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_STRING\n\n @param node the node\n @param val the string value. The string is copied when set and will be\n\t\tfreed by the node."]
    pub fn plist_set_string_val(node: plist_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_BOOLEAN\n\n @param node the node\n @param val the boolean value"]
    pub fn plist_set_bool_val(node: plist_t, val: u8);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_INT\n\n @param node the node\n @param val the unsigned integer value"]
    pub fn plist_set_uint_val(node: plist_t, val: u64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_INT\n\n @param node the node\n @param val the signed integer value"]
    pub fn plist_set_int_val(node: plist_t, val: i64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_REAL\n\n @param node the node\n @param val the real value"]
    pub fn plist_set_real_val(node: plist_t, val: f64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_DATA\n\n @param node the node\n @param val the binary buffer. The buffer is copied when set and will\n\t\tbe freed by the node.\n @param length the length of the buffer"]
    pub fn plist_set_data_val(node: plist_t, val: *const ::std::os::raw::c_char, length: u64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_DATE\n\n @param node the node\n @param sec the number of seconds since 01/01/1970 (UNIX timestamp)"]
    pub fn plist_set_unix_date_val(node: plist_t, sec: i64);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_UID\n\n @param node the node\n @param val the unsigned integer value"]
    pub fn plist_set_uid_val(node: plist_t, val: u64);
}
extern "C" {
    #[doc = " Export the #plist_t structure to XML format.\n\n @param plist the root node to export\n @param plist_xml a pointer to a C-string. This function allocates the memory,\n            caller is responsible for freeing it. Data is UTF-8 encoded.\n @param length a pointer to an uint32_t variable. Represents the length of the allocated buffer.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_to_xml(
        plist: plist_t,
        plist_xml: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Export the #plist_t structure to binary format.\n\n @param plist the root node to export\n @param plist_bin a pointer to a char* buffer. This function allocates the memory,\n            caller is responsible for freeing it.\n @param length a pointer to an uint32_t variable. Represents the length of the allocated buffer.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_to_bin(
        plist: plist_t,
        plist_bin: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Export the #plist_t structure to JSON format.\n\n @param plist the root node to export\n @param plist_json a pointer to a char* buffer. This function allocates the memory,\n     caller is responsible for freeing it.\n @param length a pointer to an uint32_t variable. Represents the length of the allocated buffer.\n @param prettify pretty print the output if != 0\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_to_json(
        plist: plist_t,
        plist_json: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
        prettify: ::std::os::raw::c_int,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Export the #plist_t structure to OpenStep format.\n\n @param plist the root node to export\n @param plist_openstep a pointer to a char* buffer. This function allocates the memory,\n     caller is responsible for freeing it.\n @param length a pointer to an uint32_t variable. Represents the length of the allocated buffer.\n @param prettify pretty print the output if != 0\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_to_openstep(
        plist: plist_t,
        plist_openstep: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
        prettify: ::std::os::raw::c_int,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure from XML format.\n\n @param plist_xml a pointer to the xml buffer.\n @param length length of the buffer to read.\n @param plist a pointer to the imported plist.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_from_xml(
        plist_xml: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure from binary format.\n\n @param plist_bin a pointer to the xml buffer.\n @param length length of the buffer to read.\n @param plist a pointer to the imported plist.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_from_bin(
        plist_bin: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure from JSON format.\n\n @param json a pointer to the JSON buffer.\n @param length length of the buffer to read.\n @param plist a pointer to the imported plist.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_from_json(
        json: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure from OpenStep plist format.\n\n @param openstep a pointer to the OpenStep plist buffer.\n @param length length of the buffer to read.\n @param plist a pointer to the imported plist.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_from_openstep(
        openstep: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure from memory data.\n\n This function will look at the first bytes of plist_data\n to determine if plist_data contains a binary, JSON, OpenStep, or XML plist\n and tries to parse the data in the appropriate format.\n @note This is just a convenience function and the format detection is\n     very basic. It checks with plist_is_binary() if the data supposedly\n     contains binary plist data, if not it checks if the first bytes have\n     either '{' or '[' and assumes JSON format, and XML tags will result\n     in parsing as XML, otherwise it will try to parse as OpenStep.\n\n @param plist_data A pointer to the memory buffer containing plist data.\n @param length Length of the buffer to read.\n @param plist A pointer to the imported plist.\n @param format If non-NULL, the #plist_format_t value pointed to will be set to the parsed format.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_from_memory(
        plist_data: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
        format: *mut plist_format_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Import the #plist_t structure directly from file.\n\n This function will look at the first bytes of the file data\n to determine if it contains a binary, JSON, OpenStep, or XML plist\n and tries to parse the data in the appropriate format.\n Uses plist_from_memory() internally.\n\n @param filename The name of the file to parse.\n @param plist A pointer to the imported plist.\n @param format If non-NULL, the #plist_format_t value pointed to will be set to the parsed format.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure"]
    pub fn plist_read_from_file(
        filename: *const ::std::os::raw::c_char,
        plist: *mut plist_t,
        format: *mut plist_format_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Write the #plist_t structure to a NULL-terminated string using the given format and options.\n\n @param plist The input plist structure\n @param output Pointer to a char* buffer. This function allocates the memory,\n     caller is responsible for freeing it.\n @param length A pointer to a uint32_t value that will receive the lenght of the allocated buffer.\n @param format A #plist_format_t value that specifies the output format to use.\n @param options One or more bitwise ORed values of #plist_write_options_t.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure.\n @note Use plist_mem_free() to free the allocated memory.\n @note #PLIST_FORMAT_BINARY is not supported by this function."]
    pub fn plist_write_to_string(
        plist: plist_t,
        output: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
        format: plist_format_t,
        options: plist_write_options_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Write the #plist_t structure to a FILE* stream using the given format and options.\n\n @param plist The input plist structure\n @param stream A writeable FILE* stream that the data will be written to.\n @param format A #plist_format_t value that specifies the output format to use.\n @param options One or more bitwise ORed values of #plist_write_options_t.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure.\n @note While this function allows all formats to be written to the given stream,\n     only the formats #PLIST_FORMAT_PRINT, #PLIST_FORMAT_LIMD, and #PLIST_FORMAT_PLUTIL\n     (basically all output-only formats) are directly and efficiently written to the stream;\n     the other formats are written to a memory buffer first."]
    pub fn plist_write_to_stream(
        plist: plist_t,
        stream: *mut FILE,
        format: plist_format_t,
        options: plist_write_options_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Write the #plist_t structure to a file at given path using the given format and options.\n\n @param plist The input plist structure\n @param filename The file name of the file to write to. Existing files will be overwritten.\n @param format A #plist_format_t value that specifies the output format to use.\n @param options One or more bitwise ORed values of #plist_write_options_t.\n @return PLIST_ERR_SUCCESS on success or a #plist_err_t on failure.\n @note Use plist_mem_free() to free the allocated memory."]
    pub fn plist_write_to_file(
        plist: plist_t,
        filename: *const ::std::os::raw::c_char,
        format: plist_format_t,
        options: plist_write_options_t,
    ) -> plist_err_t;
}
extern "C" {
    #[doc = " Print the given plist in human-readable format to standard output.\n This is equivalent to\n <code>plist_write_to_stream(plist, stdout, PLIST_FORMAT_PRINT, PLIST_OPT_PARTIAL_DATA);</code>\n @param plist The #plist_t structure to print\n @note For #PLIST_DATA nodes, only a maximum of 24 bytes (first 16 and last 8) are written."]
    pub fn plist_print(plist: plist_t);
}
extern "C" {
    #[doc = " Test if in-memory plist data is in binary format.\n This function will look at the first bytes of plist_data to determine\n if it supposedly contains a binary plist.\n @note The function is not validating the whole memory buffer to check\n if the content is truly a plist, it is only using some heuristic on\n the first few bytes of plist_data.\n\n @param plist_data a pointer to the memory buffer containing plist data.\n @param length length of the buffer to read.\n @return 1 if the buffer is a binary plist, 0 otherwise."]
    pub fn plist_is_binary(
        plist_data: *const ::std::os::raw::c_char,
        length: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a node from its path. Each path element depends on the associated father node type.\n For Dictionaries, var args are casted to const char*, for arrays, var args are caster to uint32_t\n Search is breath first order.\n\n @param plist the node to access result from.\n @param length length of the path to access\n @return the value to access."]
    pub fn plist_access_path(plist: plist_t, length: u32, ...) -> plist_t;
}
extern "C" {
    #[doc = " Variadic version of #plist_access_path.\n\n @param plist the node to access result from.\n @param length length of the path to access\n @param v list of array's index and dic'st key\n @return the value to access."]
    pub fn plist_access_pathv(plist: plist_t, length: u32, v: *mut __va_list_tag) -> plist_t;
}
extern "C" {
    #[doc = " Compare two node values\n\n @param node_l left node to compare\n @param node_r rigth node to compare\n @return TRUE is type and value match, FALSE otherwise."]
    pub fn plist_compare_node_value(node_l: plist_t, node_r: plist_t) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Helper function to check the value of a PLIST_BOOL node.\n\n @param boolnode node of type PLIST_BOOL\n @return 1 if the boolean node has a value of TRUE or 0 if FALSE."]
    pub fn plist_bool_val_is_true(boolnode: plist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to test if a given #PLIST_INT node's value is negative\n\n @param intnode node of type PLIST_INT\n @return 1 if the node's value is negative, or 0 if positive."]
    pub fn plist_int_val_is_negative(intnode: plist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_INT node against\n a given signed integer value.\n\n @param uintnode node of type PLIST_INT\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are equal,\n         1 if the node's value is greater than cmpval,\n         or -1 if the node's value is less than cmpval."]
    pub fn plist_int_val_compare(uintnode: plist_t, cmpval: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_INT node against\n a given unsigned integer value.\n\n @param uintnode node of type PLIST_INT\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are equal,\n         1 if the node's value is greater than cmpval,\n         or -1 if the node's value is less than cmpval."]
    pub fn plist_uint_val_compare(uintnode: plist_t, cmpval: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_UID node against\n a given value.\n\n @param uidnode node of type PLIST_UID\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are equal,\n         1 if the node's value is greater than cmpval,\n         or -1 if the node's value is less than cmpval."]
    pub fn plist_uid_val_compare(uidnode: plist_t, cmpval: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_REAL node against\n a given value.\n\n @note WARNING: Comparing floating point values can give inaccurate\n     results because of the nature of floating point values on computer\n     systems. While this function is designed to be as accurate as\n     possible, please don't rely on it too much.\n\n @param realnode node of type PLIST_REAL\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are (almost) equal,\n         1 if the node's value is greater than cmpval,\n         or -1 if the node's value is less than cmpval."]
    pub fn plist_real_val_compare(realnode: plist_t, cmpval: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_DATE node against\n a given number of seconds since epoch (UNIX timestamp).\n\n @param datenode node of type PLIST_DATE\n @param cmpval Number of seconds to compare against (UNIX timestamp)\n @return 0 if the node's date is equal to the supplied values,\n         1 if the node's date is greater than the supplied values,\n         or -1 if the node's date is less than the supplied values."]
    pub fn plist_unix_date_val_compare(datenode: plist_t, cmpval: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_STRING node against\n a given value.\n This function basically behaves like strcmp.\n\n @param strnode node of type PLIST_STRING\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_string_val_compare(
        strnode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_STRING node against\n a given value, while not comparing more than n characters.\n This function basically behaves like strncmp.\n\n @param strnode node of type PLIST_STRING\n @param cmpval value to compare against\n @param n maximum number of characters to compare\n @return 0 if the node's value and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_string_val_compare_with_size(
        strnode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to match a given substring in the value of a\n PLIST_STRING node.\n\n @param strnode node of type PLIST_STRING\n @param substr value to match\n @return 1 if the node's value contains the given substring,\n     or 0 if not."]
    pub fn plist_string_val_contains(
        strnode: plist_t,
        substr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_KEY node against\n a given value.\n This function basically behaves like strcmp.\n\n @param keynode node of type PLIST_KEY\n @param cmpval value to compare against\n @return 0 if the node's value and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_key_val_compare(
        keynode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_KEY node against\n a given value, while not comparing more than n characters.\n This function basically behaves like strncmp.\n\n @param keynode node of type PLIST_KEY\n @param cmpval value to compare against\n @param n maximum number of characters to compare\n @return 0 if the node's value and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_key_val_compare_with_size(
        keynode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to match a given substring in the value of a\n PLIST_KEY node.\n\n @param keynode node of type PLIST_KEY\n @param substr value to match\n @return 1 if the node's value contains the given substring,\n     or 0 if not."]
    pub fn plist_key_val_contains(
        keynode: plist_t,
        substr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the data of a PLIST_DATA node against\n a given blob and size.\n This function basically behaves like memcmp after making sure the\n size of the node's data value is equal to the size of cmpval (n),\n making this a \"full match\" comparison.\n\n @param datanode node of type PLIST_DATA\n @param cmpval data blob to compare against\n @param n size of data blob passed in cmpval\n @return 0 if the node's data blob and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_data_val_compare(
        datanode: plist_t,
        cmpval: *const u8,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to compare the data of a PLIST_DATA node against\n a given blob and size, while no more than n bytes are compared.\n This function basically behaves like memcmp after making sure the\n size of the node's data value is at least n, making this a\n \"starts with\" comparison.\n\n @param datanode node of type PLIST_DATA\n @param cmpval data blob to compare against\n @param n size of data blob passed in cmpval\n @return 0 if the node's value and cmpval are equal,\n     > 0 if the node's value is lexicographically greater than cmpval,\n     or < 0 if the node's value is lexicographically less than cmpval."]
    pub fn plist_data_val_compare_with_size(
        datanode: plist_t,
        cmpval: *const u8,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to match a given data blob within the value of a\n PLIST_DATA node.\n\n @param datanode node of type PLIST_KEY\n @param cmpval data blob to match\n @param n size of data blob passed in cmpval\n @return 1 if the node's value contains the given data blob\n     or 0 if not."]
    pub fn plist_data_val_contains(
        datanode: plist_t,
        cmpval: *const u8,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sort all PLIST_DICT key/value pairs in a property list lexicographically\n by key. Recurses into the child nodes if necessary.\n\n @param plist The property list to perform the sorting operation on."]
    pub fn plist_sort(plist: plist_t);
}
extern "C" {
    #[doc = " Free memory allocated by relevant libplist API calls:\n - plist_to_xml()\n - plist_to_bin()\n - plist_get_key_val()\n - plist_get_string_val()\n - plist_get_data_val()\n\n @param ptr pointer to the memory to free\n\n @note Do not use this function to free plist_t nodes, use plist_free()\n     instead."]
    pub fn plist_mem_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Set debug level for the format parsers.\n @note This function does nothing if libplist was not configured with --enable-debug .\n\n @param debug Debug level. Currently, only 0 (off) and 1 (enabled) are supported."]
    pub fn plist_set_debug(debug: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns a static string of the libplist version.\n\n @return The libplist version as static ascii string"]
    pub fn libplist_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create a new plist_t type #PLIST_DATE\n\n @deprecated Deprecated. Use plist_new_unix_date instead.\n\n @param sec the number of seconds since 01/01/2001\n @param usec the number of microseconds\n @return the created item\n @sa #plist_type"]
    pub fn plist_new_date(sec: i32, usec: i32) -> plist_t;
}
extern "C" {
    #[doc = " Get the value of a #PLIST_DATE node.\n This function does nothing if node is not of type #PLIST_DATE\n\n @deprecated Deprecated. Use plist_get_unix_date_val instead.\n\n @param node the node\n @param sec a pointer to an int32_t variable. Represents the number of seconds since 01/01/2001.\n @param usec a pointer to an int32_t variable. Represents the number of microseconds"]
    pub fn plist_get_date_val(node: plist_t, sec: *mut i32, usec: *mut i32);
}
extern "C" {
    #[doc = " Set the value of a node.\n Forces type of node to #PLIST_DATE\n\n @deprecated Deprecated. Use plist_set_unix_date_val instead.\n\n @param node the node\n @param sec the number of seconds since 01/01/2001\n @param usec the number of microseconds"]
    pub fn plist_set_date_val(node: plist_t, sec: i32, usec: i32);
}
extern "C" {
    #[doc = " Helper function to compare the value of a PLIST_DATE node against\n a given set of seconds and fraction of a second since epoch.\n\n @deprecated Deprecated. Use plist_unix_date_val_compare instead.\n\n @param datenode node of type PLIST_DATE\n @param cmpsec number of seconds since epoch to compare against\n @param cmpusec fraction of a second in microseconds to compare against\n @return 0 if the node's date is equal to the supplied values,\n         1 if the node's date is greater than the supplied values,\n         or -1 if the node's date is less than the supplied values."]
    pub fn plist_date_val_compare(
        datenode: plist_t,
        cmpsec: i32,
        cmpusec: i32,
    ) -> ::std::os::raw::c_int;
}
pub const idevice_error_t_IDEVICE_E_SUCCESS: idevice_error_t = 0;
pub const idevice_error_t_IDEVICE_E_INVALID_ARG: idevice_error_t = -1;
pub const idevice_error_t_IDEVICE_E_UNKNOWN_ERROR: idevice_error_t = -2;
pub const idevice_error_t_IDEVICE_E_NO_DEVICE: idevice_error_t = -3;
pub const idevice_error_t_IDEVICE_E_NOT_ENOUGH_DATA: idevice_error_t = -4;
pub const idevice_error_t_IDEVICE_E_CONNREFUSED: idevice_error_t = -5;
pub const idevice_error_t_IDEVICE_E_SSL_ERROR: idevice_error_t = -6;
pub const idevice_error_t_IDEVICE_E_TIMEOUT: idevice_error_t = -7;
#[doc = " Error Codes"]
pub type idevice_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_private {
    _unused: [u8; 0],
}
pub type idevice_t = *mut idevice_private;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_connection_private {
    _unused: [u8; 0],
}
pub type idevice_connection_t = *mut idevice_connection_private;
#[doc = "< include USBMUX devices during lookup"]
pub const idevice_options_IDEVICE_LOOKUP_USBMUX: idevice_options = 2;
#[doc = "< include network devices during lookup"]
pub const idevice_options_IDEVICE_LOOKUP_NETWORK: idevice_options = 4;
#[doc = "< prefer network connection if device is available via USBMUX *and* network"]
pub const idevice_options_IDEVICE_LOOKUP_PREFER_NETWORK: idevice_options = 8;
#[doc = " Options for idevice_new_with_options()"]
pub type idevice_options = ::std::os::raw::c_uint;
#[doc = "< device is available via USBMUX"]
pub const idevice_connection_type_CONNECTION_USBMUXD: idevice_connection_type = 1;
#[doc = "< device is available via network"]
pub const idevice_connection_type_CONNECTION_NETWORK: idevice_connection_type = 2;
#[doc = " Type of connection a device is available on"]
pub type idevice_connection_type = ::std::os::raw::c_uint;
#[doc = " Device information returned by #idevice_get_device_list_extended API"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct idevice_info {
    #[doc = "< UDID of the device"]
    pub udid: *mut ::std::os::raw::c_char,
    #[doc = "< Type of connection the device is available on"]
    pub conn_type: idevice_connection_type,
    #[doc = "< Connection data, depending on the connection type"]
    pub conn_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_idevice_info() {
    const UNINIT: ::std::mem::MaybeUninit<idevice_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<idevice_info>(),
        24usize,
        concat!("Size of: ", stringify!(idevice_info))
    );
    assert_eq!(
        ::std::mem::align_of::<idevice_info>(),
        8usize,
        concat!("Alignment of ", stringify!(idevice_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_info),
            "::",
            stringify!(udid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_info),
            "::",
            stringify!(conn_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_info),
            "::",
            stringify!(conn_data)
        )
    );
}
pub type idevice_info_t = *mut idevice_info;
#[doc = "< device was added"]
pub const idevice_event_type_IDEVICE_DEVICE_ADD: idevice_event_type = 1;
#[doc = "< device was removed"]
pub const idevice_event_type_IDEVICE_DEVICE_REMOVE: idevice_event_type = 2;
#[doc = "< device completed pairing process"]
pub const idevice_event_type_IDEVICE_DEVICE_PAIRED: idevice_event_type = 3;
#[doc = " The event type for device add or removal"]
pub type idevice_event_type = ::std::os::raw::c_uint;
#[doc = " Provides information about the occurred event."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct idevice_event_t {
    #[doc = "< The event type."]
    pub event: idevice_event_type,
    #[doc = "< The device unique id."]
    pub udid: *const ::std::os::raw::c_char,
    #[doc = "< The connection type."]
    pub conn_type: idevice_connection_type,
}
#[test]
fn bindgen_test_layout_idevice_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<idevice_event_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<idevice_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(idevice_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<idevice_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(idevice_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_event_t),
            "::",
            stringify!(udid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_event_t),
            "::",
            stringify!(conn_type)
        )
    );
}
#[doc = " Callback to notifiy if a device was added or removed."]
pub type idevice_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(event: *const idevice_event_t, user_data: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_subscription_context {
    _unused: [u8; 0],
}
#[doc = " Event subscription context type"]
pub type idevice_subscription_context_t = *mut idevice_subscription_context;
extern "C" {
    #[doc = " Set the level of debugging.\n\n @param level Set to 0 for no debug output or 1 to enable debug output."]
    pub fn idevice_set_debug_level(level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Subscribe a callback function that will be called when device add/remove\n events occur.\n\n @param context A pointer to a idevice_subscription_context_t that will be\n    set upon creation of the subscription. The returned context must be\n    passed to idevice_events_unsubscribe() to unsubscribe the callback.\n @param callback Callback function to call.\n @param user_data Application-specific data passed as parameter\n   to the registered callback function.\n\n @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    pub fn idevice_events_subscribe(
        context: *mut idevice_subscription_context_t,
        callback: idevice_event_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Unsubscribe the event callback function that has been registered with\n idevice_events_subscribe().\n\n @param context A valid context as returned from idevice_events_subscribe().\n\n @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    pub fn idevice_events_unsubscribe(context: idevice_subscription_context_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " (DEPRECATED) Register a callback function that will be called when device add/remove\n events occur.\n\n @deprecated Use idevice_events_subscribe() instead.\n\n @param callback Callback function to call.\n @param user_data Application-specific data passed as parameter\n   to the registered callback function.\n\n @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    pub fn idevice_event_subscribe(
        callback: idevice_event_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " (DEPRECATED) Release the event callback function that has been registered with\n  idevice_event_subscribe().\n\n @deprecated Use idevice_events_unsubscribe() instead.\n\n @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    pub fn idevice_event_unsubscribe() -> idevice_error_t;
}
extern "C" {
    #[doc = " Get a list of UDIDs of currently available devices (USBMUX devices only).\n\n @param devices List of UDIDs of devices that are currently available.\n   This list is terminated by a NULL pointer.\n @param count Number of devices found.\n\n @return IDEVICE_E_SUCCESS on success or an error value when an error occurred.\n\n @note This function only returns the UDIDs of USBMUX devices. To also include\n   network devices in the list, use idevice_get_device_list_extended().\n @see idevice_get_device_list_extended"]
    pub fn idevice_get_device_list(
        devices: *mut *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_int,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Free a list of device UDIDs.\n\n @param devices List of UDIDs to free.\n\n @return Always returnes IDEVICE_E_SUCCESS."]
    pub fn idevice_device_list_free(devices: *mut *mut ::std::os::raw::c_char) -> idevice_error_t;
}
extern "C" {
    #[doc = " Get a list of currently available devices\n\n @param devices List of idevice_info_t records with device information.\n   This list is terminated by a NULL pointer.\n @param count Number of devices included in the list.\n\n @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    pub fn idevice_get_device_list_extended(
        devices: *mut *mut idevice_info_t,
        count: *mut ::std::os::raw::c_int,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Free an extended device list retrieved through idevice_get_device_list_extended().\n\n @param devices Device list to free.\n\n @return IDEVICE_E_SUCCESS on success or an error value when an error occurred."]
    pub fn idevice_device_list_extended_free(devices: *mut idevice_info_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " Creates an idevice_t structure for the device specified by UDID,\n  if the device is available (USBMUX devices only).\n\n @note The resulting idevice_t structure has to be freed with\n idevice_free() if it is no longer used.\n If you need to connect to a device available via network, use\n idevice_new_with_options() and include IDEVICE_LOOKUP_NETWORK in options.\n\n @see idevice_new_with_options\n\n @param device Upon calling this function, a pointer to a location of type\n  idevice_t. On successful return, this location will be populated.\n @param udid The UDID to match.\n\n @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_new(
        device: *mut idevice_t,
        udid: *const ::std::os::raw::c_char,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Creates an idevice_t structure for the device specified by UDID,\n  if the device is available, with the given lookup options.\n\n @note The resulting idevice_t structure has to be freed with\n idevice_free() if it is no longer used.\n\n @param device Upon calling this function, a pointer to a location of type\n   idevice_t. On successful return, this location will be populated.\n @param udid The UDID to match.\n @param options Specifies what connection types should be considered\n   when looking up devices. Accepts bitwise or'ed values of idevice_options.\n   If 0 (no option) is specified it will default to IDEVICE_LOOKUP_USBMUX.\n   To lookup both USB and network-connected devices, pass\n   IDEVICE_LOOKUP_USBMUX | IDEVICE_LOOKUP_NETWORK. If a device is available\n   both via USBMUX *and* network, it will select the USB connection.\n   This behavior can be changed by adding IDEVICE_LOOKUP_PREFER_NETWORK\n   to the options in which case it will select the network connection.\n\n @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_new_with_options(
        device: *mut idevice_t,
        udid: *const ::std::os::raw::c_char,
        options: idevice_options,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Cleans up an idevice structure, then frees the structure itself.\n\n @param device idevice_t to free."]
    pub fn idevice_free(device: idevice_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " Set up a connection to the given device.\n\n @param device The device to connect to.\n @param port The destination port to connect to.\n @param connection Pointer to an idevice_connection_t that will be filled\n   with the necessary data of the connection.\n\n @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_connect(
        device: idevice_t,
        port: u16,
        connection: *mut idevice_connection_t,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Disconnect from the device and clean up the connection structure.\n\n @param connection The connection to close.\n\n @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_disconnect(connection: idevice_connection_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " Send data to a device via the given connection.\n\n @param connection The connection to send data over.\n @param data Buffer with data to send.\n @param len Size of the buffer to send.\n @param sent_bytes Pointer to an uint32_t that will be filled\n   with the number of bytes actually sent.\n\n @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_connection_send(
        connection: idevice_connection_t,
        data: *const ::std::os::raw::c_char,
        len: u32,
        sent_bytes: *mut u32,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Receive data from a device via the given connection.\n This function will return after the given timeout even if no data has been\n received.\n\n @param connection The connection to receive data from.\n @param data Buffer that will be filled with the received data.\n   This buffer has to be large enough to hold len bytes.\n @param len Buffer size or number of bytes to receive.\n @param recv_bytes Number of bytes actually received.\n @param timeout Timeout in milliseconds after which this function should\n   return even if no data has been received.\n\n @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_connection_receive_timeout(
        connection: idevice_connection_t,
        data: *mut ::std::os::raw::c_char,
        len: u32,
        recv_bytes: *mut u32,
        timeout: ::std::os::raw::c_uint,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Receive data from a device via the given connection.\n This function is like idevice_connection_receive_timeout, but with a\n predefined reasonable timeout.\n\n @param connection The connection to receive data from.\n @param data Buffer that will be filled with the received data.\n   This buffer has to be large enough to hold len bytes.\n @param len Buffer size or number of bytes to receive.\n @param recv_bytes Number of bytes actually received.\n\n @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_connection_receive(
        connection: idevice_connection_t,
        data: *mut ::std::os::raw::c_char,
        len: u32,
        recv_bytes: *mut u32,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Enables SSL for the given connection.\n\n @param connection The connection to enable SSL for.\n\n @return IDEVICE_E_SUCCESS on success, IDEVICE_E_INVALID_ARG when connection\n     is NULL or connection->ssl_data is non-NULL, or IDEVICE_E_SSL_ERROR when\n     SSL initialization, setup, or handshake fails."]
    pub fn idevice_connection_enable_ssl(connection: idevice_connection_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " Disable SSL for the given connection.\n\n @param connection The connection to disable SSL for.\n\n @return IDEVICE_E_SUCCESS on success, IDEVICE_E_INVALID_ARG when connection\n     is NULL. This function also returns IDEVICE_E_SUCCESS when SSL is not\n     enabled and does no further error checking on cleanup."]
    pub fn idevice_connection_disable_ssl(connection: idevice_connection_t) -> idevice_error_t;
}
extern "C" {
    #[doc = " Disable bypass SSL for the given connection without sending out terminate messages.\n\n @param connection The connection to disable SSL for.\n @param sslBypass  if true ssl connection will not be terminated but just cleaned up, allowing\n                   plain text data going on underlying connection\n\n @return IDEVICE_E_SUCCESS on success, IDEVICE_E_INVALID_ARG when connection\n     is NULL. This function also returns IDEVICE_E_SUCCESS when SSL is not\n     enabled and does no further error checking on cleanup."]
    pub fn idevice_connection_disable_bypass_ssl(
        connection: idevice_connection_t,
        sslBypass: u8,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Get the underlying file descriptor for a connection\n\n @param connection The connection to get fd of\n @param fd Pointer to an int where the fd is stored\n\n @return IDEVICE_E_SUCCESS if ok, otherwise an error code."]
    pub fn idevice_connection_get_fd(
        connection: idevice_connection_t,
        fd: *mut ::std::os::raw::c_int,
    ) -> idevice_error_t;
}
extern "C" {
    #[doc = " Gets the handle or (USBMUX device id) of the device.\n\n @param device The device to get the USBMUX device id for.\n @param handle Pointer to a uint32_t that will be set to the USBMUX handle value.\n\n @return IDEVICE_E_SUCCESS on success, otherwise an error code."]
    pub fn idevice_get_handle(device: idevice_t, handle: *mut u32) -> idevice_error_t;
}
extern "C" {
    #[doc = " Gets the Unique Device ID for the device.\n\n @param device The device to get the Unique Device ID for.\n @param udid Pointer that will be set to an allocated buffer with the device UDID. The consumer is responsible for releasing the allocated memory.\n\n @return IDEVICE_E_SUCCESS on success, otherwise an error code."]
    pub fn idevice_get_udid(
        device: idevice_t,
        udid: *mut *mut ::std::os::raw::c_char,
    ) -> idevice_error_t;
}
pub const lockdownd_error_t_LOCKDOWN_E_SUCCESS: lockdownd_error_t = 0;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_ARG: lockdownd_error_t = -1;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_CONF: lockdownd_error_t = -2;
pub const lockdownd_error_t_LOCKDOWN_E_PLIST_ERROR: lockdownd_error_t = -3;
pub const lockdownd_error_t_LOCKDOWN_E_PAIRING_FAILED: lockdownd_error_t = -4;
pub const lockdownd_error_t_LOCKDOWN_E_SSL_ERROR: lockdownd_error_t = -5;
pub const lockdownd_error_t_LOCKDOWN_E_DICT_ERROR: lockdownd_error_t = -6;
pub const lockdownd_error_t_LOCKDOWN_E_RECEIVE_TIMEOUT: lockdownd_error_t = -7;
pub const lockdownd_error_t_LOCKDOWN_E_MUX_ERROR: lockdownd_error_t = -8;
pub const lockdownd_error_t_LOCKDOWN_E_NO_RUNNING_SESSION: lockdownd_error_t = -9;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_RESPONSE: lockdownd_error_t = -10;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_KEY: lockdownd_error_t = -11;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_VALUE: lockdownd_error_t = -12;
pub const lockdownd_error_t_LOCKDOWN_E_GET_PROHIBITED: lockdownd_error_t = -13;
pub const lockdownd_error_t_LOCKDOWN_E_SET_PROHIBITED: lockdownd_error_t = -14;
pub const lockdownd_error_t_LOCKDOWN_E_REMOVE_PROHIBITED: lockdownd_error_t = -15;
pub const lockdownd_error_t_LOCKDOWN_E_IMMUTABLE_VALUE: lockdownd_error_t = -16;
pub const lockdownd_error_t_LOCKDOWN_E_PASSWORD_PROTECTED: lockdownd_error_t = -17;
pub const lockdownd_error_t_LOCKDOWN_E_USER_DENIED_PAIRING: lockdownd_error_t = -18;
pub const lockdownd_error_t_LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING: lockdownd_error_t = -19;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_HOST_ID: lockdownd_error_t = -20;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_HOST_ID: lockdownd_error_t = -21;
pub const lockdownd_error_t_LOCKDOWN_E_SESSION_ACTIVE: lockdownd_error_t = -22;
pub const lockdownd_error_t_LOCKDOWN_E_SESSION_INACTIVE: lockdownd_error_t = -23;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_SESSION_ID: lockdownd_error_t = -24;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_SESSION_ID: lockdownd_error_t = -25;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_SERVICE: lockdownd_error_t = -26;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_SERVICE: lockdownd_error_t = -27;
pub const lockdownd_error_t_LOCKDOWN_E_SERVICE_LIMIT: lockdownd_error_t = -28;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_PAIR_RECORD: lockdownd_error_t = -29;
pub const lockdownd_error_t_LOCKDOWN_E_SAVE_PAIR_RECORD_FAILED: lockdownd_error_t = -30;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_PAIR_RECORD: lockdownd_error_t = -31;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_ACTIVATION_RECORD: lockdownd_error_t = -32;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_ACTIVATION_RECORD: lockdownd_error_t = -33;
pub const lockdownd_error_t_LOCKDOWN_E_SERVICE_PROHIBITED: lockdownd_error_t = -34;
pub const lockdownd_error_t_LOCKDOWN_E_ESCROW_LOCKED: lockdownd_error_t = -35;
pub const lockdownd_error_t_LOCKDOWN_E_PAIRING_PROHIBITED_OVER_THIS_CONNECTION: lockdownd_error_t =
    -36;
pub const lockdownd_error_t_LOCKDOWN_E_FMIP_PROTECTED: lockdownd_error_t = -37;
pub const lockdownd_error_t_LOCKDOWN_E_MC_PROTECTED: lockdownd_error_t = -38;
pub const lockdownd_error_t_LOCKDOWN_E_MC_CHALLENGE_REQUIRED: lockdownd_error_t = -39;
pub const lockdownd_error_t_LOCKDOWN_E_UNKNOWN_ERROR: lockdownd_error_t = -256;
#[doc = " Error Codes"]
pub type lockdownd_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdownd_client_private {
    _unused: [u8; 0],
}
pub type lockdownd_client_t = *mut lockdownd_client_private;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct lockdownd_pair_record {
    #[doc = "< The device certificate"]
    pub device_certificate: *mut ::std::os::raw::c_char,
    #[doc = "< The host certificate"]
    pub host_certificate: *mut ::std::os::raw::c_char,
    #[doc = "< The root certificate"]
    pub root_certificate: *mut ::std::os::raw::c_char,
    #[doc = "< A unique HostID for the host computer"]
    pub host_id: *mut ::std::os::raw::c_char,
    #[doc = "< A unique system id"]
    pub system_buid: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lockdownd_pair_record() {
    const UNINIT: ::std::mem::MaybeUninit<lockdownd_pair_record> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lockdownd_pair_record>(),
        40usize,
        concat!("Size of: ", stringify!(lockdownd_pair_record))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdownd_pair_record>(),
        8usize,
        concat!("Alignment of ", stringify!(lockdownd_pair_record))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_certificate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(device_certificate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_certificate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(host_certificate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root_certificate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(root_certificate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(host_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_buid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(system_buid)
        )
    );
}
#[doc = " pair record holding device, host and root certificates along the host_id"]
pub type lockdownd_pair_record_t = *mut lockdownd_pair_record;
#[doc = " service descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct lockdownd_service_descriptor {
    #[doc = "< port number the service was started on"]
    pub port: u16,
    #[doc = "< an indicator if the service requires SSL"]
    pub ssl_enabled: u8,
    #[doc = "< identifier of the service"]
    pub identifier: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lockdownd_service_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<lockdownd_service_descriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lockdownd_service_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(lockdownd_service_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdownd_service_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(lockdownd_service_descriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_service_descriptor),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ssl_enabled) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_service_descriptor),
            "::",
            stringify!(ssl_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_service_descriptor),
            "::",
            stringify!(identifier)
        )
    );
}
pub type lockdownd_service_descriptor_t = *mut lockdownd_service_descriptor;
#[doc = "< PIN requested: data_ptr is a char* buffer, and data_size points to the size of this buffer that must not be exceeded and has to be updated to the actual number of characters filled into the buffer."]
pub const lockdownd_cu_pairing_cb_type_t_LOCKDOWN_CU_PAIRING_PIN_REQUESTED:
    lockdownd_cu_pairing_cb_type_t = 0;
#[doc = "< device information available: data_ptr is a plist_t, and data_size is ignored. The plist_t has to be copied if required, since it is freed when the callback function returns."]
pub const lockdownd_cu_pairing_cb_type_t_LOCKDOWN_CU_PAIRING_DEVICE_INFO:
    lockdownd_cu_pairing_cb_type_t = 1;
#[doc = "< pairing error message available: data_ptr is a NULL-terminated char* buffer containing the error message, and data_size is ignored. Buffer needs to be copied if it shall persist outside the callback."]
pub const lockdownd_cu_pairing_cb_type_t_LOCKDOWN_CU_PAIRING_ERROR: lockdownd_cu_pairing_cb_type_t =
    2;
#[doc = " Callback types used in #lockdownd_cu_pairing_cb_t"]
pub type lockdownd_cu_pairing_cb_type_t = ::std::os::raw::c_uint;
#[doc = " Callback used to supply the pairing PIN during a CU pairing session,\n  and to report device information and pairing error messages."]
pub type lockdownd_cu_pairing_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        cb_type: lockdownd_cu_pairing_cb_type_t,
        user_data: *mut ::std::os::raw::c_void,
        data_ptr: *mut ::std::os::raw::c_void,
        data_size: *mut ::std::os::raw::c_uint,
    ),
>;
extern "C" {
    #[doc = " Creates a new lockdownd client for the device.\n\n @note This function does not pair with the device or start a session. This\n  has to be done manually by the caller after the client is created.\n  The device disconnects automatically if the lockdown connection idles\n  for more than 10 seconds. Make sure to call lockdownd_client_free() as soon\n  as the connection is no longer needed.\n\n @param device The device to create a lockdownd client for\n @param client The pointer to the location of the new lockdownd_client\n @param label The label to use for communication. Usually the program name.\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_client_new(
        device: idevice_t,
        client: *mut lockdownd_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Creates a new lockdownd client for the device and starts initial handshake.\n The handshake consists out of query_type, validate_pair, pair and\n start_session calls. It uses the internal pairing record management.\n\n @note The device disconnects automatically if the lockdown connection idles\n  for more than 10 seconds. Make sure to call lockdownd_client_free() as soon\n  as the connection is no longer needed.\n\n @param device The device to create a lockdownd client for\n @param client The pointer to the location of the new lockdownd_client\n @param label The label to use for communication. Usually the program name.\n  Pass NULL to disable sending the label in requests to lockdownd.\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,\n  LOCKDOWN_E_INVALID_CONF if configuration data is wrong"]
    pub fn lockdownd_client_new_with_handshake(
        device: idevice_t,
        client: *mut lockdownd_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Closes the lockdownd client session if one is running and frees up the\n lockdownd_client struct.\n\n @param client The lockdown client\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_client_free(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Query the type of the service daemon. Depending on whether the device is\n queried in normal mode or restore mode, different types will be returned.\n\n @param client The lockdownd client\n @param type The type returned by the service daemon. Pass NULL to ignore.\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_query_type(
        client: lockdownd_client_t,
        type_: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Retrieves a preferences plist using an optional domain and/or key name.\n\n @param client An initialized lockdownd client.\n @param domain The domain to query on or NULL for global domain\n @param key The key name to request or NULL to query for all keys\n @param value A plist node representing the result value node\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_get_value(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: *mut plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Sets a preferences value using a plist and optional by domain and/or key name.\n\n @param client an initialized lockdownd client.\n @param domain the domain to query on or NULL for global domain\n @param key the key name to set the value or NULL to set a value dict plist\n @param value a plist node of any node type representing the value to set\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client or\n  value is NULL"]
    pub fn lockdownd_set_value(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Removes a preference node by domain and/or key name.\n\n @note: Use with caution as this could remove vital information on the device\n\n @param client An initialized lockdownd client.\n @param domain The domain to query on or NULL for global domain\n @param key The key name to remove or NULL remove all keys for the current domain\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_remove_value(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Requests to start a service and retrieve it's port on success.\n\n @param client The lockdownd client\n @param identifier The identifier of the service to start\n @param service The service descriptor on success or NULL on failure\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG if a parameter\n  is NULL, LOCKDOWN_E_INVALID_SERVICE if the requested service is not known\n  by the device, LOCKDOWN_E_START_SERVICE_FAILED if the service could not be\n  started by the device"]
    pub fn lockdownd_start_service(
        client: lockdownd_client_t,
        identifier: *const ::std::os::raw::c_char,
        service: *mut lockdownd_service_descriptor_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Requests to start a service and retrieve it's port on success.\n Sends the escrow bag from the device's pair record.\n\n @param client The lockdownd client\n @param identifier The identifier of the service to start\n @param service The service descriptor on success or NULL on failure\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG if a parameter\n  is NULL, LOCKDOWN_E_INVALID_SERVICE if the requested service is not known\n  by the device, LOCKDOWN_E_START_SERVICE_FAILED if the service could not because\n  started by the device, LOCKDOWN_E_INVALID_CONF if the host id or escrow bag are\n  missing from the device record."]
    pub fn lockdownd_start_service_with_escrow_bag(
        client: lockdownd_client_t,
        identifier: *const ::std::os::raw::c_char,
        service: *mut lockdownd_service_descriptor_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Opens a session with lockdownd and switches to SSL mode if device wants it.\n\n @param client The lockdownd client\n @param host_id The HostID of the computer\n @param session_id The new session_id of the created session\n @param ssl_enabled Whether SSL communication is used in the session\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when a client\n  or host_id is NULL, LOCKDOWN_E_PLIST_ERROR if the response plist had errors,\n  LOCKDOWN_E_INVALID_HOST_ID if the device does not know the supplied HostID,\n  LOCKDOWN_E_SSL_ERROR if enabling SSL communication failed"]
    pub fn lockdownd_start_session(
        client: lockdownd_client_t,
        host_id: *const ::std::os::raw::c_char,
        session_id: *mut *mut ::std::os::raw::c_char,
        ssl_enabled: *mut ::std::os::raw::c_int,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Closes the lockdownd session by sending the StopSession request.\n\n @see lockdownd_start_session\n\n @param client The lockdown client\n @param session_id The id of a running session\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_stop_session(
        client: lockdownd_client_t,
        session_id: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Sends a plist to lockdownd.\n\n @note This function is low-level and should only be used if you need to send\n        a new type of message.\n\n @param client The lockdownd client\n @param plist The plist to send\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client or\n  plist is NULL"]
    pub fn lockdownd_send(client: lockdownd_client_t, plist: plist_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Receives a plist from lockdownd.\n\n @param client The lockdownd client\n @param plist The plist to store the received data\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client or\n  plist is NULL"]
    pub fn lockdownd_receive(client: lockdownd_client_t, plist: *mut plist_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Pairs the device using the supplied pair record.\n\n @param client The lockdown client\n @param pair_record The pair record to use for pairing. If NULL is passed, then\n    the pair records from the current machine are used. New records will be\n    generated automatically when pairing is done for the first time.\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,\n  LOCKDOWN_E_PLIST_ERROR if the pair_record certificates are wrong,\n  LOCKDOWN_E_PAIRING_FAILED if the pairing failed,\n  LOCKDOWN_E_PASSWORD_PROTECTED if the device is password protected,\n  LOCKDOWN_E_INVALID_HOST_ID if the device does not know the caller's host id"]
    pub fn lockdownd_pair(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Pairs the device using the supplied pair record and passing the given options.\n\n @param client The lockdown client\n @param pair_record The pair record to use for pairing. If NULL is passed, then\n    the pair records from the current machine are used. New records will be\n    generated automatically when pairing is done for the first time.\n @param options The pairing options to pass. Can be NULL for no options.\n @param response If non-NULL a pointer to lockdownd's response dictionary is returned.\n    The caller is responsible to free the response dictionary with plist_free().\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,\n  LOCKDOWN_E_PLIST_ERROR if the pair_record certificates are wrong,\n  LOCKDOWN_E_PAIRING_FAILED if the pairing failed,\n  LOCKDOWN_E_PASSWORD_PROTECTED if the device is password protected,\n  LOCKDOWN_E_INVALID_HOST_ID if the device does not know the caller's host id"]
    pub fn lockdownd_pair_with_options(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
        options: plist_t,
        response: *mut plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Validates if the device is paired with the given HostID. If successful the\n specified host will become trusted host of the device indicated by the\n lockdownd preference named TrustedHostAttached. Otherwise the host must be\n paired using lockdownd_pair() first.\n\n @param client The lockdown client\n @param pair_record The pair record to validate pairing with. If NULL is\n    passed, then the pair record is read from the internal pairing record\n    management.\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,\n  LOCKDOWN_E_PLIST_ERROR if the pair_record certificates are wrong,\n  LOCKDOWN_E_PAIRING_FAILED if the pairing failed,\n  LOCKDOWN_E_PASSWORD_PROTECTED if the device is password protected,\n  LOCKDOWN_E_INVALID_HOST_ID if the device does not know the caller's host id"]
    pub fn lockdownd_validate_pair(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Unpairs the device with the given HostID and removes the pairing records\n from the device and host if the internal pairing record management is used.\n\n @param client The lockdown client\n @param pair_record The pair record to use for unpair. If NULL is passed, then\n    the pair records from the current machine are used.\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,\n  LOCKDOWN_E_PLIST_ERROR if the pair_record certificates are wrong,\n  LOCKDOWN_E_PAIRING_FAILED if the pairing failed,\n  LOCKDOWN_E_PASSWORD_PROTECTED if the device is password protected,\n  LOCKDOWN_E_INVALID_HOST_ID if the device does not know the caller's host id"]
    pub fn lockdownd_unpair(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Activates the device. Only works within an open session.\n The ActivationRecord plist dictionary must be obtained using the\n activation protocol requesting from Apple's https webservice.\n\n @param client The lockdown client\n @param activation_record The activation record plist dictionary\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client or\n  activation_record is NULL, LOCKDOWN_E_NO_RUNNING_SESSION if no session is\n  open, LOCKDOWN_E_PLIST_ERROR if the received plist is broken,\n  LOCKDOWN_E_ACTIVATION_FAILED if the activation failed,\n  LOCKDOWN_E_INVALID_ACTIVATION_RECORD if the device reports that the\n  activation_record is invalid"]
    pub fn lockdownd_activate(
        client: lockdownd_client_t,
        activation_record: plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Deactivates the device, returning it to the locked Activate with iTunes\n screen.\n\n @param client The lockdown client\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL,\n  LOCKDOWN_E_NO_RUNNING_SESSION if no session is open,\n  LOCKDOWN_E_PLIST_ERROR if the received plist is broken"]
    pub fn lockdownd_deactivate(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Tells the device to immediately enter recovery mode.\n\n @param client The lockdown client\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client is NULL"]
    pub fn lockdownd_enter_recovery(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Sends the Goodbye request to lockdownd signaling the end of communication.\n\n @param client The lockdown client\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client\n  is NULL, LOCKDOWN_E_PLIST_ERROR if the device did not acknowledge the\n  request"]
    pub fn lockdownd_goodbye(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Creates a CU pairing session for the current lockdown client.\n This is required to allow lockdownd_cu_send_request_and_get_reply(),\n lockdownd_get_value_cu() and lockdonwd_pair_cu() requests, and eventually\n allows to perform an actual wireless pairing.\n\n Through the callback function, the PIN displayed on the device has to be\n supplied during the process. Currently, only AppleTV devices have this\n capability.\n\n @param client  The lockdown client to perform the CU pairing for\n @param pairing_callback  Callback function that is used to supply the PIN\n   for the pairing process, but also to receive device information or\n   pairing error messages.\n @param cb_user_data  User data that will be passed as additional argument\n   to the callback function.\n @param host_info  (Optional) A dictionary containing host information to\n   send to the device when finalizing the CU pairing. The supplied\n   values will override the default values gathered for the current host.\n @param acl  (Optional) A dictionary containing ACL information. Currently\n   only com.apple.ScreenCapture:true and com.apple.developer:true are known\n   valid ACL values, which are used as default when NULL is passed.\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG if one of the\n   parameters is invalid, LOCKDOWN_E_PAIRING_FAILED if the pairing failed,\n   or a LOCKDOWN_E_* error code otherwise."]
    pub fn lockdownd_cu_pairing_create(
        client: lockdownd_client_t,
        pairing_callback: lockdownd_cu_pairing_cb_t,
        cb_user_data: *mut ::std::os::raw::c_void,
        host_info: plist_t,
        acl: plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Sends a request via lockdown client with established CU pairing session\n and attempts to retrieve a reply. This function is used internally\n by lockdownd_get_value_cu() and lockdownd_pair_cu(), but exposed here to\n allow custom requests being sent and their replies being received.\n\n @param client  A lockdown client with an established CU pairing.\n @param request  The request to perform.\n @param request_payload  The payload for the request.\n @param reply  (Optional) If not NULL, the plist_t will be set to the reply\n   dictionary that has been received. Consumer is responsible to free it\n   using plist_free() when no longer required.\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG if one of the\n   parameters is invalid, LOCKDOWN_E_NO_RUNNING_SESSION if the current\n   lockdown client does not have an established CU pairing session,\n   or a LOCKDOWN_E_* error code otherwise."]
    pub fn lockdownd_cu_send_request_and_get_reply(
        client: lockdownd_client_t,
        request: *const ::std::os::raw::c_char,
        request_payload: plist_t,
        reply: *mut plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Retrieves a value using an optional domain and/or key name from a lockdown\n client with established CU pairing session.\n\n This is used to retrieve values that are only accessible after a CU pairing\n has been established, and would otherwise only be accessible with a valid\n device pairing.\n\n @param client  A lockdown client with an established CU pairing.\n @param domain  The domain to query on or NULL for global domain\n @param key  The key name to request or NULL to query for all keys\n @param value  A plist node representing the result value node\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG if one of the\n   parameters is invalid, LOCKDOWN_E_NO_RUNNING_SESSION if the current\n   lockdown client does not have an established CU pairing session,\n   or a LOCKDOWN_E_* error code otherwise."]
    pub fn lockdownd_get_value_cu(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: *mut plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Perform a device pairing with a lockdown client that has an established\n CU pairing session.\n\n @param client A lockdown client with an established CU pairing.\n\n @return LOCKDOWN_E_SUCCESS on success, LOCKDOWN_E_INVALID_ARG when client\n   is NULL, LOCKDOWN_E_NO_RUNNING_SESSION if the current lockdown client\n   does not have an established CU pairing session, or a LOCKDOWN_E_* error\n   code otherwise."]
    pub fn lockdownd_pair_cu(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Sets the label to send for requests to lockdownd.\n\n @param client The lockdown client\n @param label The label to set or NULL to disable sending a label\n"]
    pub fn lockdownd_client_set_label(
        client: lockdownd_client_t,
        label: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Returns the unique id of the device from lockdownd.\n\n @param client An initialized lockdownd client.\n @param udid Holds the unique id of the device. The caller is responsible\n  for freeing the memory.\n\n @return LOCKDOWN_E_SUCCESS on success"]
    pub fn lockdownd_get_device_udid(
        client: lockdownd_client_t,
        udid: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Retrieves the name of the device from lockdownd set by the user.\n\n @param client An initialized lockdownd client.\n @param device_name Holds the name of the device. The caller is\n  responsible for freeing the memory.\n\n @return LOCKDOWN_E_SUCCESS on success"]
    pub fn lockdownd_get_device_name(
        client: lockdownd_client_t,
        device_name: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Calculates and returns the data classes the device supports from lockdownd.\n\n @param client An initialized lockdownd client.\n @param classes A pointer to store an array of class names. The caller is responsible\n  for freeing the memory which can be done using mobilesync_data_classes_free().\n @param count The number of items in the classes array.\n\n @return LOCKDOWN_E_SUCCESS on success,\n  LOCKDOWN_E_INVALID_ARG when client is NULL,\n  LOCKDOWN_E_NO_RUNNING_SESSION if no session is open,\n  LOCKDOWN_E_PLIST_ERROR if the received plist is broken"]
    pub fn lockdownd_get_sync_data_classes(
        client: lockdownd_client_t,
        classes: *mut *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_int,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Frees memory of an allocated array of data classes as returned by lockdownd_get_sync_data_classes()\n\n @param classes An array of class names to free.\n\n @return LOCKDOWN_E_SUCCESS on success"]
    pub fn lockdownd_data_classes_free(
        classes: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Frees memory of a service descriptor as returned by lockdownd_start_service()\n\n @param service A service descriptor instance to free.\n\n @return LOCKDOWN_E_SUCCESS on success"]
    pub fn lockdownd_service_descriptor_free(
        service: lockdownd_service_descriptor_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    #[doc = " Gets a readable error string for a given lockdown error code.\n\n @param err A lockdownd error code\n\n @returns A readable error string"]
    pub fn lockdownd_strerror(err: lockdownd_error_t) -> *const ::std::os::raw::c_char;
}
pub const afc_error_t_AFC_E_SUCCESS: afc_error_t = 0;
pub const afc_error_t_AFC_E_UNKNOWN_ERROR: afc_error_t = 1;
pub const afc_error_t_AFC_E_OP_HEADER_INVALID: afc_error_t = 2;
pub const afc_error_t_AFC_E_NO_RESOURCES: afc_error_t = 3;
pub const afc_error_t_AFC_E_READ_ERROR: afc_error_t = 4;
pub const afc_error_t_AFC_E_WRITE_ERROR: afc_error_t = 5;
pub const afc_error_t_AFC_E_UNKNOWN_PACKET_TYPE: afc_error_t = 6;
pub const afc_error_t_AFC_E_INVALID_ARG: afc_error_t = 7;
pub const afc_error_t_AFC_E_OBJECT_NOT_FOUND: afc_error_t = 8;
pub const afc_error_t_AFC_E_OBJECT_IS_DIR: afc_error_t = 9;
pub const afc_error_t_AFC_E_PERM_DENIED: afc_error_t = 10;
pub const afc_error_t_AFC_E_SERVICE_NOT_CONNECTED: afc_error_t = 11;
pub const afc_error_t_AFC_E_OP_TIMEOUT: afc_error_t = 12;
pub const afc_error_t_AFC_E_TOO_MUCH_DATA: afc_error_t = 13;
pub const afc_error_t_AFC_E_END_OF_DATA: afc_error_t = 14;
pub const afc_error_t_AFC_E_OP_NOT_SUPPORTED: afc_error_t = 15;
pub const afc_error_t_AFC_E_OBJECT_EXISTS: afc_error_t = 16;
pub const afc_error_t_AFC_E_OBJECT_BUSY: afc_error_t = 17;
pub const afc_error_t_AFC_E_NO_SPACE_LEFT: afc_error_t = 18;
pub const afc_error_t_AFC_E_OP_WOULD_BLOCK: afc_error_t = 19;
pub const afc_error_t_AFC_E_IO_ERROR: afc_error_t = 20;
pub const afc_error_t_AFC_E_OP_INTERRUPTED: afc_error_t = 21;
pub const afc_error_t_AFC_E_OP_IN_PROGRESS: afc_error_t = 22;
pub const afc_error_t_AFC_E_INTERNAL_ERROR: afc_error_t = 23;
pub const afc_error_t_AFC_E_MUX_ERROR: afc_error_t = 30;
pub const afc_error_t_AFC_E_NO_MEM: afc_error_t = 31;
pub const afc_error_t_AFC_E_NOT_ENOUGH_DATA: afc_error_t = 32;
pub const afc_error_t_AFC_E_DIR_NOT_EMPTY: afc_error_t = 33;
pub const afc_error_t_AFC_E_FORCE_SIGNED_TYPE: afc_error_t = -1;
#[doc = " Error Codes"]
pub type afc_error_t = ::std::os::raw::c_int;
#[doc = "< r   O_RDONLY"]
pub const afc_file_mode_t_AFC_FOPEN_RDONLY: afc_file_mode_t = 1;
#[doc = "< r+  O_RDWR   | O_CREAT"]
pub const afc_file_mode_t_AFC_FOPEN_RW: afc_file_mode_t = 2;
#[doc = "< w   O_WRONLY | O_CREAT  | O_TRUNC"]
pub const afc_file_mode_t_AFC_FOPEN_WRONLY: afc_file_mode_t = 3;
#[doc = "< w+  O_RDWR   | O_CREAT  | O_TRUNC"]
pub const afc_file_mode_t_AFC_FOPEN_WR: afc_file_mode_t = 4;
#[doc = "< a   O_WRONLY | O_APPEND | O_CREAT"]
pub const afc_file_mode_t_AFC_FOPEN_APPEND: afc_file_mode_t = 5;
#[doc = "< a+  O_RDWR   | O_APPEND | O_CREAT"]
pub const afc_file_mode_t_AFC_FOPEN_RDAPPEND: afc_file_mode_t = 6;
#[doc = " Flags for afc_file_open"]
pub type afc_file_mode_t = u64; //::std::os::raw::c_uint;
pub const afc_link_type_t_AFC_HARDLINK: afc_link_type_t = 1;
pub const afc_link_type_t_AFC_SYMLINK: afc_link_type_t = 2;
#[doc = " Type of link for afc_make_link() calls"]
pub type afc_link_type_t = ::std::os::raw::c_uint;
#[doc = "< shared lock"]
pub const afc_lock_op_t_AFC_LOCK_SH: afc_lock_op_t = 5;
#[doc = "< exclusive lock"]
pub const afc_lock_op_t_AFC_LOCK_EX: afc_lock_op_t = 6;
#[doc = "< unlock"]
pub const afc_lock_op_t_AFC_LOCK_UN: afc_lock_op_t = 12;
#[doc = " Lock operation flags"]
pub type afc_lock_op_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct afc_client_private {
    _unused: [u8; 0],
}
pub type afc_client_t = *mut afc_client_private;
extern "C" {
    #[doc = " Makes a connection to the AFC service on the device.\n\n @param device The device to connect to.\n @param service The service descriptor returned by lockdownd_start_service.\n @param client Pointer that will be set to a newly allocated afc_client_t\n        upon successful return.\n\n @return AFC_E_SUCCESS on success, AFC_E_INVALID_ARG if device or service is\n         invalid, AFC_E_MUX_ERROR if the connection cannot be established,\n         or AFC_E_NO_MEM if there is a memory allocation problem."]
    pub fn afc_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut afc_client_t,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Starts a new AFC service on the specified device and connects to it.\n\n @param device The device to connect to.\n @param client Pointer that will point to a newly allocated afc_client_t upon\n        successful return. Must be freed using afc_client_free() after use.\n @param label The label to use for communication. Usually the program name.\n        Pass NULL to disable sending the label in requests to lockdownd.\n\n @return AFC_E_SUCCESS on success, or an AFC_E_* error code otherwise."]
    pub fn afc_client_start_service(
        device: idevice_t,
        client: *mut afc_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Frees up an AFC client. If the connection was created by the client itself,\n the connection will be closed.\n\n @param client The client to free."]
    pub fn afc_client_free(client: afc_client_t) -> afc_error_t;
}
extern "C" {
    #[doc = " Get device information for a connected client. The device information\n returned is the device model as well as the free space, the total capacity\n and blocksize on the accessed disk partition.\n\n @param client The client to get device info for.\n @param device_information A char list of device information terminated by an\n        empty string or NULL if there was an error. Free with\n        afc_dictionary_free().\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_get_device_info(
        client: afc_client_t,
        device_information: *mut *mut *mut ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Gets a directory listing of the directory requested.\n\n @param client The client to get a directory listing from.\n @param path The directory for listing. (must be a fully-qualified path)\n @param directory_information A char list of files in the directory\n        terminated by an empty string or NULL if there was an error. Free with\n        afc_dictionary_free().\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_read_directory(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
        directory_information: *mut *mut *mut ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Gets information about a specific file.\n\n @param client The client to use to get the information of the file.\n @param path The fully-qualified path to the file.\n @param file_information Pointer to a buffer that will be filled with a\n        NULL-terminated list of strings with the file information. Set to NULL\n        before calling this function. Free with afc_dictionary_free().\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_get_file_info(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
        file_information: *mut *mut *mut ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Opens a file on the device.\n\n @param client The client to use to open the file.\n @param filename The file to open. (must be a fully-qualified path)\n @param file_mode The mode to use to open the file.\n @param handle Pointer to a uint64_t that will hold the handle of the file\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_file_open(
        client: afc_client_t,
        filename: *const ::std::os::raw::c_char,
        file_mode: afc_file_mode_t,
        handle: *mut u64,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Closes a file on the device.\n\n @param client The client to close the file with.\n @param handle File handle of a previously opened file."]
    pub fn afc_file_close(client: afc_client_t, handle: u64) -> afc_error_t;
}
extern "C" {
    #[doc = " Locks or unlocks a file on the device.\n\n Makes use of flock on the device.\n @see http://developer.apple.com/documentation/Darwin/Reference/ManPages/man2/flock.2.html\n\n @param client The client to lock the file with.\n @param handle File handle of a previously opened file.\n @param operation the lock or unlock operation to perform, this is one of\n        AFC_LOCK_SH (shared lock), AFC_LOCK_EX (exclusive lock), or\n        AFC_LOCK_UN (unlock)."]
    pub fn afc_file_lock(
        client: afc_client_t,
        handle: u64,
        operation: afc_lock_op_t,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Attempts to the read the given number of bytes from the given file.\n\n @param client The relevant AFC client\n @param handle File handle of a previously opened file\n @param data The pointer to the memory region to store the read data\n @param length The number of bytes to read\n @param bytes_read The number of bytes actually read.\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_file_read(
        client: afc_client_t,
        handle: u64,
        data: *mut ::std::os::raw::c_char,
        length: u32,
        bytes_read: *mut u32,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Writes a given number of bytes to a file.\n\n @param client The client to use to write to the file.\n @param handle File handle of previously opened file.\n @param data The data to write to the file.\n @param length How much data to write.\n @param bytes_written The number of bytes actually written to the file.\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_file_write(
        client: afc_client_t,
        handle: u64,
        data: *const ::std::os::raw::c_char,
        length: u32,
        bytes_written: *mut u32,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Seeks to a given position of a pre-opened file on the device.\n\n @param client The client to use to seek to the position.\n @param handle File handle of a previously opened.\n @param offset Seek offset.\n @param whence Seeking direction, one of SEEK_SET, SEEK_CUR, or SEEK_END.\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_file_seek(
        client: afc_client_t,
        handle: u64,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Returns current position in a pre-opened file on the device.\n\n @param client The client to use.\n @param handle File handle of a previously opened file.\n @param position Position in bytes of indicator\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_file_tell(client: afc_client_t, handle: u64, position: *mut u64) -> afc_error_t;
}
extern "C" {
    #[doc = " Sets the size of a file on the device.\n\n @param client The client to use to set the file size.\n @param handle File handle of a previously opened file.\n @param newsize The size to set the file to.\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value.\n\n @note This function is more akin to ftruncate than truncate, and truncate\n       calls would have to open the file before calling this, sadly."]
    pub fn afc_file_truncate(client: afc_client_t, handle: u64, newsize: u64) -> afc_error_t;
}
extern "C" {
    #[doc = " Deletes a file or directory.\n\n @param client The client to use.\n @param path The path to delete. (must be a fully-qualified path)\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_remove_path(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Renames a file or directory on the device.\n\n @param client The client to have rename.\n @param from The name to rename from. (must be a fully-qualified path)\n @param to The new name. (must also be a fully-qualified path)\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_rename_path(
        client: afc_client_t,
        from: *const ::std::os::raw::c_char,
        to: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Creates a directory on the device.\n\n @param client The client to use to make a directory.\n @param path The directory's path. (must be a fully-qualified path, I assume\n        all other mkdir restrictions apply as well)\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_make_directory(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Sets the size of a file on the device without prior opening it.\n\n @param client The client to use to set the file size.\n @param path The path of the file to be truncated.\n @param newsize The size to set the file to.\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_truncate(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
        newsize: u64,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Creates a hard link or symbolic link on the device.\n\n @param client The client to use for making a link\n @param linktype 1 = hard link, 2 = symlink\n @param target The file to be linked.\n @param linkname The name of link.\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_make_link(
        client: afc_client_t,
        linktype: afc_link_type_t,
        target: *const ::std::os::raw::c_char,
        linkname: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Sets the modification time of a file on the device.\n\n @param client The client to use to set the file size.\n @param path Path of the file for which the modification time should be set.\n @param mtime The modification time to set in nanoseconds since epoch.\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_set_file_time(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
        mtime: u64,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Deletes a file or directory including possible contents.\n\n @param client The client to use.\n @param path The path to delete. (must be a fully-qualified path)\n @since libimobiledevice 1.1.7\n @note Only available in iOS 6 and later.\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_remove_path_and_contents(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Get a specific key of the device info list for a client connection.\n Known key values are: Model, FSTotalBytes, FSFreeBytes and FSBlockSize.\n This is a helper function for afc_get_device_info().\n\n @param client The client to get device info for.\n @param key The key to get the value of.\n @param value The value for the key if successful or NULL otherwise.\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_get_device_info_key(
        client: afc_client_t,
        key: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Frees up a char dictionary as returned by some AFC functions.\n\n @param dictionary The char array terminated by an empty string.\n\n @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_dictionary_free(dictionary: *mut *mut ::std::os::raw::c_char) -> afc_error_t;
}
#[doc = "< include USBMUX devices during lookup"]
pub const usbmux_lookup_options_DEVICE_LOOKUP_USBMUX: usbmux_lookup_options = 2;
#[doc = "< include network devices during lookup"]
pub const usbmux_lookup_options_DEVICE_LOOKUP_NETWORK: usbmux_lookup_options = 4;
#[doc = "< prefer network connection if device is available via USBMUX *and* network"]
pub const usbmux_lookup_options_DEVICE_LOOKUP_PREFER_NETWORK: usbmux_lookup_options = 8;
#[doc = " Device lookup options for usbmuxd_get_device."]
pub type usbmux_lookup_options = ::std::os::raw::c_uint;
pub const usbmux_connection_type_CONNECTION_TYPE_USB: usbmux_connection_type = 1;
pub const usbmux_connection_type_CONNECTION_TYPE_NETWORK: usbmux_connection_type = 2;
#[doc = " Type of connection a device is available on"]
pub type usbmux_connection_type = ::std::os::raw::c_uint;
#[doc = " Device information structure holding data to identify the device.\n The relevant 'handle' should be passed to 'usbmuxd_connect()', to\n start a proxy connection.  The value 'handle' should be considered\n opaque and no presumption made about the meaning of its value."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct usbmuxd_device_info_t {
    pub handle: u32,
    pub product_id: u32,
    pub udid: [::std::os::raw::c_char; 44usize],
    pub conn_type: usbmux_connection_type,
    pub conn_data: [u8; 200usize],
}
#[test]
fn bindgen_test_layout_usbmuxd_device_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<usbmuxd_device_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<usbmuxd_device_info_t>(),
        256usize,
        concat!("Size of: ", stringify!(usbmuxd_device_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<usbmuxd_device_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(usbmuxd_device_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbmuxd_device_info_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).product_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbmuxd_device_info_t),
            "::",
            stringify!(product_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbmuxd_device_info_t),
            "::",
            stringify!(udid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_type) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(usbmuxd_device_info_t),
            "::",
            stringify!(conn_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(usbmuxd_device_info_t),
            "::",
            stringify!(conn_data)
        )
    );
}
pub const usbmuxd_event_type_UE_DEVICE_ADD: usbmuxd_event_type = 1;
pub const usbmuxd_event_type_UE_DEVICE_REMOVE: usbmuxd_event_type = 2;
pub const usbmuxd_event_type_UE_DEVICE_PAIRED: usbmuxd_event_type = 3;
#[doc = " event types for event callback function"]
pub type usbmuxd_event_type = ::std::os::raw::c_uint;
#[doc = " Event structure that will be passed to the callback function.\n 'event' will contains the type of the event, and 'device' will contains\n information about the device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct usbmuxd_event_t {
    pub event: ::std::os::raw::c_int,
    pub device: usbmuxd_device_info_t,
}
#[test]
fn bindgen_test_layout_usbmuxd_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<usbmuxd_event_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<usbmuxd_event_t>(),
        260usize,
        concat!("Size of: ", stringify!(usbmuxd_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<usbmuxd_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(usbmuxd_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbmuxd_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbmuxd_event_t),
            "::",
            stringify!(device)
        )
    );
}
#[doc = " Callback function prototype."]
pub type usbmuxd_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(event: *const usbmuxd_event_t, user_data: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbmuxd_subscription_context {
    _unused: [u8; 0],
}
#[doc = " Subscription context type."]
pub type usbmuxd_subscription_context_t = *mut usbmuxd_subscription_context;
extern "C" {
    #[doc = " Subscribe a callback function to be called upon device add/remove events.\n This method can be called multiple times to register multiple callbacks\n since every subscription will have its own context (returned in the\n first parameter).\n\n @param context A pointer to a usbmuxd_subscription_context_t that will be\n    set upon creation of the subscription. The returned context must be\n    passed to usbmuxd_events_unsubscribe() to unsubscribe the callback.\n @param callback A callback function that is executed when an event occurs.\n @param user_data Custom data passed on to the callback function. The data\n    needs to be kept available until the callback function is unsubscribed.\n\n @return 0 on success or a negative errno value."]
    pub fn usbmuxd_events_subscribe(
        context: *mut usbmuxd_subscription_context_t,
        callback: usbmuxd_event_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unsubscribe callback function\n\n @param context A valid context as returned from usbmuxd_events_subscribe().\n\n @return 0 on success or a negative errno value."]
    pub fn usbmuxd_events_unsubscribe(
        context: usbmuxd_subscription_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Subscribe a callback (deprecated)\n\n @param callback A callback function that is executed when an event occurs.\n @param user_data Custom data passed on to the callback function. The data\n    needs to be kept available until the callback function is unsubscribed.\n\n @return 0 on success or negative on error.\n\n @note Deprecated. Use usbmuxd_events_subscribe and usbmuxd_events_unsubscribe instead.\n @see usbmuxd_events_subscribe"]
    pub fn usbmuxd_subscribe(
        callback: usbmuxd_event_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unsubscribe callback (deprecated)\n\n @return 0 on success or negative on error.\n\n @note Deprecated. Use usbmuxd_events_subscribe and usbmuxd_events_unsubscribe instead.\n @see usbmuxd_events_unsubscribe"]
    pub fn usbmuxd_unsubscribe() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Contacts usbmuxd and retrieves a list of connected devices.\n\n @param device_list A pointer to an array of usbmuxd_device_info_t\n      that will hold records of the connected devices. The last record\n      is a null-terminated record with all fields set to 0/NULL.\n @note The user has to free the list returned.\n\n @return number of attached devices, zero on no devices, or negative\n   if an error occured."]
    pub fn usbmuxd_get_device_list(
        device_list: *mut *mut usbmuxd_device_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees the device list returned by an usbmuxd_get_device_list call\n\n @param device_list A pointer to an array of usbmuxd_device_info_t to free.\n\n @return 0 on success, -1 on error."]
    pub fn usbmuxd_device_list_free(
        device_list: *mut *mut usbmuxd_device_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Looks up the device specified by UDID and returns device information.\n\n @note This function only considers devices connected through USB. To\n      query devices available via network, use usbmuxd_get_device().\n\n @see usbmuxd_get_device\n\n @param udid A device UDID of the device to look for. If udid is NULL,\n      This function will return the first device found.\n @param device Pointer to a previously allocated (or static)\n      usbmuxd_device_info_t that will be filled with the device info.\n\n @return 0 if no matching device is connected, 1 if the device was found,\n    or a negative value on error."]
    pub fn usbmuxd_get_device_by_udid(
        udid: *const ::std::os::raw::c_char,
        device: *mut usbmuxd_device_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Looks up the device specified by UDID with given options and returns\n device information.\n\n @param udid A device UDID of the device to look for. If udid is NULL,\n      this function will return the first device found.\n @param device Pointer to a previously allocated (or static)\n      usbmuxd_device_info_t that will be filled with the device info.\n @param options Specifying what device connection types should be\n      considered during lookup. Accepts bitwise or'ed values of\n      usbmux_lookup_options.\n      If 0 (no option) is specified it will default to DEVICE_LOOKUP_USBMUX.\n      To lookup both USB and network-connected devices, pass\n      DEVICE_LOOKUP_USBMUX | DEVICE_LOOKUP_NETWORK. If a device is available\n      both via USBMUX *and* network, it will select the USB connection.\n      This behavior can be changed by adding DEVICE_LOOKUP_PREFER_NETWORK\n      to the options in which case it will select the network connection.\n\n @see enum usbmux_lookup_options\n\n @return 0 if no matching device is connected, 1 if the device was found,\n    or a negative value on error."]
    pub fn usbmuxd_get_device(
        udid: *const ::std::os::raw::c_char,
        device: *mut usbmuxd_device_info_t,
        options: usbmux_lookup_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Request proxy connection to the specified device and port.\n\n @param handle returned in the usbmux_device_info_t structure via\n      usbmuxd_get_device() or usbmuxd_get_device_list().\n\n @param tcp_port TCP port number on device, in range 0-65535.\n\tcommon values are 62078 for lockdown, and 22 for SSH.\n\n @return socket file descriptor of the connection, or a negative errno\n    value on error."]
    pub fn usbmuxd_connect(
        handle: u32,
        tcp_port: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disconnect. For now, this just closes the socket file descriptor.\n\n @param sfd socket file descriptor returned by usbmuxd_connect()\n\n @return 0 on success, -1 on error."]
    pub fn usbmuxd_disconnect(sfd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send data to the specified socket.\n\n @param sfd socket file descriptor returned by usbmuxd_connect()\n @param data buffer to send\n @param len size of buffer to send\n @param sent_bytes how many bytes sent\n\n @return 0 on success, a negative errno value otherwise."]
    pub fn usbmuxd_send(
        sfd: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_char,
        len: u32,
        sent_bytes: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive data from the specified socket.\n\n @param sfd socket file descriptor returned by usbmuxd_connect()\n @param data buffer to put the data to\n @param len number of bytes to receive\n @param recv_bytes number of bytes received\n @param timeout how many milliseconds to wait for data\n\n @return 0 on success, a negative errno value otherwise."]
    pub fn usbmuxd_recv_timeout(
        sfd: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_char,
        len: u32,
        recv_bytes: *mut u32,
        timeout: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive data from the specified socket with a default timeout.\n\n @param sfd socket file descriptor returned by usbmuxd_connect()\n @param data buffer to put the data to\n @param len number of bytes to receive\n @param recv_bytes number of bytes received\n\n @return 0 on success, a negative errno value otherwise."]
    pub fn usbmuxd_recv(
        sfd: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_char,
        len: u32,
        recv_bytes: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reads the SystemBUID\n\n @param buid pointer to a variable that will be set to point to a newly\n     allocated string with the System BUID returned by usbmuxd\n\n @return 0 on success, a negative errno value otherwise."]
    pub fn usbmuxd_read_buid(buid: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a pairing record\n\n @param record_id the record identifier of the pairing record to retrieve\n @param record_data pointer to a variable that will be set to point to a\n     newly allocated buffer containing the pairing record data\n @param record_size pointer to a variable that will be set to the size of\n     the buffer returned in record_data\n\n @return 0 on success, a negative error value otherwise."]
    pub fn usbmuxd_read_pair_record(
        record_id: *const ::std::os::raw::c_char,
        record_data: *mut *mut ::std::os::raw::c_char,
        record_size: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save a pairing record\n\n @param record_id the record identifier of the pairing record to save\n @param record_data buffer containing the pairing record data\n @param record_size size of the buffer passed in record_data\n\n @return 0 on success, a negative error value otherwise."]
    pub fn usbmuxd_save_pair_record(
        record_id: *const ::std::os::raw::c_char,
        record_data: *const ::std::os::raw::c_char,
        record_size: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save a pairing record with device identifier\n\n @param record_id the record identifier of the pairing record to save\n @param device_id the device identifier of the connected device, or 0\n @param record_data buffer containing the pairing record data\n @param record_size size of the buffer passed in record_data\n\n @return 0 on success, a negative error value otherwise."]
    pub fn usbmuxd_save_pair_record_with_device_id(
        record_id: *const ::std::os::raw::c_char,
        device_id: u32,
        record_data: *const ::std::os::raw::c_char,
        record_size: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a pairing record\n\n @param record_id the record identifier of the pairing record to delete.\n\n @return 0 on success, a negative errno value otherwise."]
    pub fn usbmuxd_delete_pair_record(
        record_id: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable the use of inotify extension. Enabled by default.\n Use 0 to disable and 1 to enable inotify support.\n This only has an effect on linux systems if inotify support has been built\n in. Otherwise and on all other platforms this function has no effect."]
    pub fn libusbmuxd_set_use_inotify(set: ::std::os::raw::c_int);
}
extern "C" {
    pub fn libusbmuxd_set_debug_level(level: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct statvfs {
    pub f_bsize: ::std::os::raw::c_ulong,
    pub f_frsize: ::std::os::raw::c_ulong,
    pub f_blocks: __fsblkcnt64_t,
    pub f_bfree: __fsblkcnt64_t,
    pub f_bavail: __fsblkcnt64_t,
    pub f_files: __fsfilcnt64_t,
    pub f_ffree: __fsfilcnt64_t,
    pub f_favail: __fsfilcnt64_t,
    pub f_fsid: ::std::os::raw::c_ulong,
    pub f_flag: ::std::os::raw::c_ulong,
    pub f_namemax: ::std::os::raw::c_ulong,
    pub f_type: ::std::os::raw::c_uint,
    pub __f_spare: [::std::os::raw::c_int; 5usize],
}
#[test]
fn bindgen_test_layout_statvfs() {
    const UNINIT: ::std::mem::MaybeUninit<statvfs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<statvfs>(),
        112usize,
        concat!("Size of: ", stringify!(statvfs))
    );
    assert_eq!(
        ::std::mem::align_of::<statvfs>(),
        8usize,
        concat!("Alignment of ", stringify!(statvfs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bsize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_bsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_frsize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_frsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_blocks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bfree) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_bfree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_bavail) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_bavail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_files) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_files)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_ffree) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_ffree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_favail) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_favail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_fsid) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_fsid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_flag) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_namemax) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_namemax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_type) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(f_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__f_spare) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(statvfs),
            "::",
            stringify!(__f_spare)
        )
    );
}
pub const ST_RDONLY: _bindgen_ty_1 = 1;
pub const ST_NOSUID: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}statvfs64"]
    pub fn statvfs(
        __file: *const ::std::os::raw::c_char,
        __buf: *mut statvfs,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}fstatvfs64"]
    pub fn fstatvfs(__fildes: ::std::os::raw::c_int, __buf: *mut statvfs) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utimbuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct fusemod_so {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
